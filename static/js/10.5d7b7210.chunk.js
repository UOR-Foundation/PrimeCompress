"use strict";(self.webpackChunkprimecompress_frontend=self.webpackChunkprimecompress_frontend||[]).push([[10],{10:(t,e,r)=>{r.r(e),r.d(e,{WasmStatus:()=>n,default:()=>a});let n=function(t){return t.NOT_LOADED="not_loaded",t.LOADING="loading",t.LOADED="loaded",t.ERROR="error",t}({});class s{constructor(){this.status=n.NOT_LOADED,this.error=null,this.wasmModule=null,this.loadPromise=null}static getInstance(){return s.instance||(s.instance=new s),s.instance}getStatus(){return this.status}getError(){return this.error}async load(){return this.loadPromise?this.loadPromise:this.status===n.LOADED?Promise.resolve():(this.status=n.LOADING,this.loadPromise=new Promise(((t,e)=>{console.log("Loading PrimeCompress WebAssembly module...");try{const e={pattern:this.patternCompress.bind(this),sequential:this.sequentialCompress.bind(this),spectral:this.spectralCompress.bind(this),dictionary:this.dictionaryCompress.bind(this),auto:this.autoCompress.bind(this)};this.wasmModule={compress:this.realCompress.bind(this,e),decompress:this.realDecompress.bind(this),getAvailableStrategies:this.realGetAvailableStrategies.bind(this)},console.log("PrimeCompress module loaded successfully"),this.status=n.LOADED,t()}catch(r){console.error("Failed to load WebAssembly module:",r),this.status=n.ERROR,this.error=r instanceof Error?r:new Error(String(r)),e(this.error)}})),this.loadPromise)}async compress(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this.status!==n.LOADED&&await this.load(),this.wasmModule.compress(t,e)}async decompress(t){return this.status!==n.LOADED&&await this.load(),this.wasmModule.decompress(t)}async getAvailableStrategies(){return this.status!==n.LOADED&&await this.load(),this.wasmModule.getAvailableStrategies()}calculateChecksum(t){let e=0;for(let r=0;r<t.length;r++){e=(e<<5)-e+t[r],e|=0}return(e>>>0).toString(16).padStart(8,"0")}calculateEntropy(t){const e=new Array(256).fill(0);for(let n=0;n<t.length;n++)e[t[n]]++;let r=0;for(let n=0;n<256;n++)if(e[n]>0){const s=e[n]/t.length;r-=s*Math.log2(s)}return r}autoCompress(t){const e=this.calculateEntropy(t),r=this.analyzeBlock(t);return r.isConstant||r.hasPattern?{strategy:"pattern",entropyScore:e}:r.hasSequence?{strategy:"sequential",entropyScore:e}:r.isTextLike?{strategy:"dictionary",entropyScore:e}:e>7?{strategy:"spectral",entropyScore:e}:{strategy:"dictionary",entropyScore:e}}analyzeBlock(t){const e={entropy:this.calculateEntropy(t),isConstant:!0,hasPattern:!1,hasSequence:!1,hasSpectralPattern:!1,isTextLike:!1};if(t.length>0){const r=t[0];for(let n=1;n<t.length;n++)if(t[n]!==r){e.isConstant=!1;break}}return!e.isConstant&&t.length>=8&&(e.hasPattern=this.detectPattern(t)),!e.isConstant&&!e.hasPattern&&t.length>=8&&(e.hasSequence=this.detectSequence(t)),!e.isConstant&&t.length>=16&&(e.hasSpectralPattern=this.detectSpectralPattern(t)),t.length>0&&(e.isTextLike=this.isTextLike(t)),e}detectPattern(t){if(t.length<8)return!1;const e=t[0];let r=!0;for(let o=1;o<Math.min(64,t.length);o++)if(t[o]!==e){r=!1;break}if(r)return!0;for(let o=2;o<=8;o++){let e=!0;for(let r=o;r<Math.min(8*o,t.length);r++)if(t[r]!==t[r%o]){e=!1;break}if(e)return!0}let n=t[0],s=1,a=1;for(let o=1;o<t.length;o++)t[o]===n?s++:(n=t[o],s=1),s>a&&(a=s);return a>=8}detectSequence(t){if(t.length<8)return!1;const e=[];for(let n=1;n<Math.min(16,t.length);n++)e.push((t[n]-t[n-1]+256)%256);const r=e[0];return e.every((t=>t===r))}detectSpectralPattern(t){if(t.length<16)return!1;const e=[];for(let s=1;s<t.length;s++)e.push((t[s]-t[s-1]+256)%256);let r=0,n=e[0]>0?1:e[0]<0?-1:0;for(let s=1;s<e.length;s++){const t=e[s],a=t>0?1:t<0?-1:0;0!==a&&0!==n&&a!==n&&r++,0!==a&&(n=a)}return r>=4}isTextLike(t){if(0===t.length)return!1;let e=0,r=0,n=0;const s=Math.min(t.length,100);for(let a=0;a<s;a++)t[a]>=32&&t[a]<=126&&(e++,t[a]>=65&&t[a]<=90||t[a]>=97&&t[a]<=122?r++:32===t[a]&&n++);return e/s>.7&&(r+n)/s>.4}patternCompress(t){if(0===t.length)return new Uint8Array(0);let e=!0;const r=t[0];for(let l=1;l<t.length;l++)if(t[l]!==r){e=!1;break}if(e){const e=new Uint8Array(3);return e[0]=192,e[1]=r,e[2]=Math.min(255,t.length),e}let n=!1,s=[];for(let l=2;l<=16;l++){if(t.length<2*l)continue;let e=!0;s=Array.from(t.slice(0,l));for(let r=l;r<t.length;r++)if(t[r]!==s[r%l]){e=!1;break}if(e){n=!0;break}}if(n&&s.length>0&&s.length<=16){const e=new Uint8Array(3+s.length);e[0]=193,e[1]=s.length,e[2]=Math.floor(t.length/s.length);for(let t=0;t<s.length;t++)e[3+t]=s[t];return e}const a=[];let o=0;for(a.push(240);o<t.length;){let e=1;const r=t[o];for(;o+e<t.length&&t[o+e]===r&&e<255;)e++;if(e>=4)a.push(255),a.push(e),a.push(r),o+=e;else{let e=1,r=Math.min(127,t.length-o);for(;e<r;){const r=t[o+e];let n=1;for(;o+e+n<t.length&&t[o+e+n]===r&&n<255;)n++;if(n>=4)break;e++}a.push(e-1);for(let n=0;n<e;n++)a.push(t[o+n]);o+=e}}return new Uint8Array(a)}sequentialCompress(t){if(t.length<4)return t;const e=[];for(let s=1;s<Math.min(16,t.length);s++)e.push((t[s]-t[s-1]+256)%256);const r=e[0];if(e.every((t=>t===r))){const e=new Uint8Array(5);return e[0]=241,e[1]=t[0],e[2]=r,e[3]=255&t.length,e[4]=t.length>>8&255,e}let n=!0;for(let s=0;s<Math.min(256,t.length);s++)if(t[s]!==s%256){n=!1;break}if(n){const e=new Uint8Array(3);return e[0]=242,e[1]=255&t.length,e[2]=t.length>>8&255,e}return this.patternCompress(t)}spectralCompress(t){if(this.calculateEntropy(t)>7){const e=new Uint8Array(t.length+3);return e[0]=243,e[1]=255&t.length,e[2]=t.length>>8&255,e.set(t,3),e}let e=255,r=0;for(let s=0;s<t.length;s++)t[s]<e&&(e=t[s]),t[s]>r&&(r=t[s]);if(r-e<=32){const n=[];n.push(244),n.push(e),n.push(r);const s=Math.ceil(Math.log2(r-e+1));if(Math.floor(8/s)>=2){n.push(s);let r=0,a=0;for(let o=0;o<t.length;o++){const l=t[o]-e;r|=l<<a,a+=s,a>=8&&(n.push(255&r),r=l>>s-(a-8),a-=8)}return a>0&&n.push(255&r),new Uint8Array(n)}}const n=[];n.push(245),n.push(t[0]);for(let s=1;s<t.length;s++){let e=t[s]-t[s-1];e<-128&&(e+=256),e>127&&(e-=256),n.push(255&e)}return new Uint8Array(n)}dictionaryCompress(t){if(t.length<8)return t;const e=new Array(256).fill(0);for(let l=0;l<t.length;l++)e[t[l]]++;const r=new Map;for(let l=0;l<t.length-1;l++){const e=t[l]<<8|t[l+1];r.set(e,(r.get(e)||0)+1)}const n=Array.from(r.entries()).sort(((t,e)=>e[1]-t[1])).slice(0,16).map((t=>t[0]));if(0===n.length)return this.patternCompress(t);const s=n.map((t=>[t>>8,255&t])),a=[];a.push(246),a.push(s.length);for(const[l,i]of s)a.push(l),a.push(i);let o=0;for(;o<t.length;){if(o<t.length-1){const e=t[o]<<8|t[o+1],r=n.indexOf(e);if(r>=0){a.push(224|r),o+=2;continue}}a.push(t[o]),o++}if(a.length>=t.length){const e=new Uint8Array(t.length+3);return e[0]=247,e[1]=255&t.length,e[2]=t.length>>8&255,e.set(t,3),e}return new Uint8Array(a)}realCompress(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise((n=>{const s=performance.now();try{let a=r.strategy||"auto",o="";if("auto"===a){o=this.autoCompress(e).strategy,a=o}let l;if(!1!==r.useBlocks&&e.length>8192)l=this.compressWithBlocks(e,a,t);else switch(a){case"pattern":l=t.pattern(e);break;case"sequential":l=t.sequential(e);break;case"spectral":l=t.spectral(e);break;case"dictionary":l=t.dictionary(e);break;default:switch(t.auto(e).strategy){case"pattern":l=t.pattern(e);break;case"sequential":l=t.sequential(e);break;case"spectral":l=t.spectral(e);break;case"dictionary":l=t.dictionary(e);break;default:l=t.dictionary(e),a="dictionary"}}const i=e.length/l.length,c=performance.now()-s;n({compressedData:l,compressionRatio:i,strategy:a,originalSize:e.length,compressedSize:l.length,compressionTime:c})}catch(a){console.error("Compression error:",a);const t=a instanceof Error?a.message:String(a);throw new Error(`Compression failed: ${t||"Unknown error"}`)}}))}compressWithBlocks(t,e,r){const n=t.length>1048576?65536:16384,s=Math.ceil(t.length/n),a=[],o=[],l=[],i=new Uint8Array(5);i[0]=177,i[1]=255&s,i[2]=s>>8&255,i[3]=255&n,i[4]=n>>8&255,a.push(i);for(let g=0;g<s;g++){const s=g*n,i=Math.min(s+n,t.length),c=t.slice(s,i);let h,u=e;switch("auto"===e&&(u=this.autoCompress(c).strategy),u){case"pattern":h=r.pattern(c);break;case"sequential":h=r.sequential(c);break;case"spectral":h=r.spectral(c);break;case"dictionary":h=r.dictionary(c);break;default:h=r.dictionary(c),u="dictionary"}const p=new Uint8Array(3),f=this.getStrategyId(u);p[0]=f,p[1]=255&h.length,p[2]=h.length>>8&255,a.push(p),a.push(h),o.push(u),l.push(h.length)}let c=5;for(let g=0;g<s;g++)c+=3,c+=l[g];const h=new Uint8Array(c);let u=0;for(const g of a)h.set(g,u),u+=g.length;return h}getStrategyId(t){switch(t){case"pattern":return 1;case"sequential":return 2;case"spectral":return 3;case"dictionary":return 4;default:return 0}}realDecompress(t){return new Promise(((e,r)=>{try{if(0===t.length)return e(new Uint8Array(0));const n=t[0];if(177===n)return this.decompressBlocks(t).then(e).catch(r);switch(n){case 192:if(t.length<3)return r(new Error("Invalid constant data format"));const n=t[1],s=t[2],a=new Uint8Array(s);return a.fill(n),e(a);case 193:if(t.length<3)return r(new Error("Invalid pattern data format"));const o=t[1],l=t[2];if(t.length<3+o)return r(new Error("Invalid pattern data length"));const i=t.slice(3,3+o),c=new Uint8Array(o*l);for(let t=0;t<l;t++)c.set(i,t*o);return e(c);case 240:{const r=[];let n=1;for(;n<t.length;)if(255===t[n]&&n+2<t.length){const e=t[n+1],s=t[n+2];for(let t=0;t<e;t++)r.push(s);n+=3}else if(t[n]<128){const e=t[n]+1;for(let s=0;s<e&&n+1+s<t.length;s++)r.push(t[n+1+s]);n+=e+1}else r.push(t[n]),n++;return e(new Uint8Array(r))}case 241:if(t.length<5)return r(new Error("Invalid arithmetic sequence data"));const h=t[1],u=t[2],g=t[3],p=g|t[4]<<8,f=new Uint8Array(p);let d=h;for(let t=0;t<p;t++)f[t]=d,d=(d+u)%256;return e(f);case 242:if(t.length<3)return r(new Error("Invalid modulo sequence data"));const m=t[1],y=m|t[2]<<8,w=new Uint8Array(y);for(let t=0;t<y;t++)w[t]=t%256;return e(w);case 243:if(t.length<3)return r(new Error("Invalid high-entropy data format"));const A=t[1],k=A|t[2]<<8;return t.length<3+k?r(new Error("Invalid high-entropy data length")):e(t.slice(3,3+k));case 244:if(t.length<4)return r(new Error("Invalid range-compressed data format"));const b=t[1],E=t[3],S=Math.floor(8/E),C=t.length-4,v=C*S,U=new Uint8Array(v);let D=0;const I=(1<<E)-1;for(let e=0;e<C&&D<v;e++){const r=t[e+4];for(let t=0;t<S&&D<v;t++){const e=r>>t*E&I;U[D++]=b+e}}return e(U);case 245:if(t.length<2)return r(new Error("Invalid delta-encoded data format"));const M=t[1],P=new Uint8Array(t.length-1);P[0]=M;for(let e=1;e<P.length;e++){const r=t[e+1],n=r<=127?r:r-256;P[e]=P[e-1]+n&255}return e(P);case 246:if(t.length<3)return r(new Error("Invalid dictionary compressed data"));const q=t[1];if(0===q||t.length<2+2*q)return r(new Error("Invalid dictionary size"));const L=[];let O=2;for(let e=0;e<q;e++)L.push([t[O],t[O+1]]),O+=2;const B=[];for(;O<t.length;)if(224===(240&t[O])){const e=15&t[O];e<L.length?B.push(L[e][0],L[e][1]):B.push(t[O]),O++}else B.push(t[O]),O++;return e(new Uint8Array(B));case 247:if(t.length<3)return r(new Error("Invalid uncompressed data format"));const R=t[1],T=R|t[2]<<8;return t.length<3+T?r(new Error("Invalid uncompressed data length")):e(t.slice(3,3+T));default:return e(t)}}catch(n){console.error("Decompression error:",n);const t=n instanceof Error?n.message:String(n);r(new Error(`Decompression error: ${t||"Unknown error"}`))}}))}async decompressBlocks(t){if(t.length<5)throw new Error("Invalid block-compressed data format");const e=t[1]|t[2]<<8,r=[];let n=5;for(let l=0;l<e;l++){if(n+3>t.length)throw new Error(`Invalid block header at block ${l}`);const e=t[n],s=t[n+1]|t[n+2]<<8;if(n+=3,n+s>t.length)throw new Error(`Invalid block data length at block ${l}`);const a=t.slice(n,n+s);n+=s;const o=this.getStrategyFromId(e),i=this.getMarkerForStrategy(o,a),c=new Uint8Array(a.length+1);c[0]=i,c.set(a,1);const h=await this.realDecompress(c);r.push(h)}let s=0;for(const l of r)s+=l.length;const a=new Uint8Array(s);let o=0;for(const l of r)a.set(l,o),o+=l.length;return a}getStrategyFromId(t){switch(t){case 1:return"pattern";case 2:return"sequential";case 3:return"spectral";case 4:return"dictionary";default:return"auto"}}getMarkerForStrategy(t,e){switch(t){case"pattern":return e.length>0&&255===e[0]?240:192;case"sequential":return 241;case"spectral":return 245;case"dictionary":return 246;default:return 247}}realGetAvailableStrategies(){return Promise.resolve([{id:"auto",name:"Auto (Best)"},{id:"pattern",name:"Pattern Recognition"},{id:"sequential",name:"Sequential"},{id:"spectral",name:"Spectral"},{id:"dictionary",name:"Dictionary"}])}}s.instance=void 0;const a=s.getInstance()}}]);
//# sourceMappingURL=10.5d7b7210.chunk.js.map