{"version":3,"file":"static/js/10.0dd038d7.chunk.js","mappings":"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","sources":["wasm/prime-compress-wasm.ts"],"sourcesContent":["/**\n * WebAssembly bindings for PrimeCompress\n * \n * This module provides a bridge between the PrimeCompress library and the browser\n * environment using WebAssembly.\n * \n * This implementation incorporates compression algorithms from unified-compression.js\n * into a JavaScript-based implementation that mimics a WebAssembly module.\n */\n\n/**\n * Interface for compression options\n */\nexport interface CompressionOptions {\n  strategy?: string;\n  useBlocks?: boolean;\n  fastPathForRandom?: boolean;\n}\n\n/**\n * WebAssembly module status\n */\nexport enum WasmStatus {\n  NOT_LOADED = 'not_loaded',\n  LOADING = 'loading',\n  LOADED = 'loaded',\n  ERROR = 'error'\n}\n\n/**\n * Singleton class to manage the WebAssembly module\n */\nclass PrimeCompressWasm {\n  private static instance: PrimeCompressWasm;\n  private status: WasmStatus = WasmStatus.NOT_LOADED;\n  private error: Error | null = null;\n  private wasmModule: any = null;\n  private loadPromise: Promise<void> | null = null;\n\n  private constructor() {\n    // Private constructor to enforce singleton pattern\n  }\n\n  /**\n   * Get the singleton instance\n   */\n  public static getInstance(): PrimeCompressWasm {\n    if (!PrimeCompressWasm.instance) {\n      PrimeCompressWasm.instance = new PrimeCompressWasm();\n    }\n    return PrimeCompressWasm.instance;\n  }\n\n  /**\n   * Get the current status of the WASM module\n   */\n  public getStatus(): WasmStatus {\n    return this.status;\n  }\n\n  /**\n   * Get any error that occurred during loading\n   */\n  public getError(): Error | null {\n    return this.error;\n  }\n\n  /**\n   * Load the WebAssembly module\n   */\n  public async load(): Promise<void> {\n    // If already loading, return the existing promise\n    if (this.loadPromise) {\n      return this.loadPromise;\n    }\n\n    // If already loaded, return immediately\n    if (this.status === WasmStatus.LOADED) {\n      return Promise.resolve();\n    }\n\n    this.status = WasmStatus.LOADING;\n    \n    this.loadPromise = new Promise<void>((resolve, reject) => {\n      console.log('Loading PrimeCompress WebAssembly module...');\n      try {\n        // Create JavaScript functions based on the algorithms from unified-compression.js\n        const strategies = {\n          pattern: this.patternCompress.bind(this),\n          sequential: this.sequentialCompress.bind(this), \n          spectral: this.spectralCompress.bind(this),\n          dictionary: this.dictionaryCompress.bind(this),\n          auto: this.autoCompress.bind(this)\n        };\n        \n        // Create module interface\n        this.wasmModule = {\n          compress: this.realCompress.bind(this, strategies),\n          decompress: this.realDecompress.bind(this),\n          getAvailableStrategies: this.realGetAvailableStrategies.bind(this)\n        };\n        \n        console.log('PrimeCompress module loaded successfully');\n        this.status = WasmStatus.LOADED;\n        resolve();\n      } catch (err) {\n        console.error('Failed to load WebAssembly module:', err);\n        this.status = WasmStatus.ERROR;\n        this.error = err instanceof Error ? err : new Error(String(err));\n        reject(this.error);\n      }\n    });\n    \n    return this.loadPromise;\n  }\n\n  /**\n   * Compress data using the WebAssembly module\n   */\n  public async compress(\n    data: Uint8Array, \n    options: CompressionOptions = {}\n  ): Promise<{ \n    compressedData: Uint8Array, \n    compressionRatio: number, \n    strategy: string,\n    originalSize: number,\n    compressedSize: number,\n    compressionTime: number\n  }> {\n    if (this.status !== WasmStatus.LOADED) {\n      await this.load();\n    }\n    \n    // Call the actual WebAssembly module's compress function\n    return this.wasmModule.compress(data, options);\n  }\n\n  /**\n   * Decompress data using the WebAssembly module\n   */\n  public async decompress(compressedData: Uint8Array): Promise<Uint8Array> {\n    if (this.status !== WasmStatus.LOADED) {\n      await this.load();\n    }\n    \n    // Call the actual WebAssembly module's decompress function\n    return this.wasmModule.decompress(compressedData);\n  }\n\n  /**\n   * Get available compression strategies\n   */\n  public async getAvailableStrategies(): Promise<{ id: string, name: string }[]> {\n    if (this.status !== WasmStatus.LOADED) {\n      await this.load();\n    }\n    \n    // Call the actual WebAssembly module's getAvailableStrategies function\n    return this.wasmModule.getAvailableStrategies();\n  }\n\n  /**\n   * Calculate checksum for data integrity\n   */\n  private calculateChecksum(data: Uint8Array): string {\n    let hash = 0;\n    \n    for (let i = 0; i < data.length; i++) {\n      const byte = data[i];\n      hash = ((hash << 5) - hash) + byte;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    \n    // Convert to hex string\n    return (hash >>> 0).toString(16).padStart(8, '0');\n  }\n\n  /**\n   * Calculate entropy of the data\n   */\n  private calculateEntropy(data: Uint8Array): number {\n    const counts = new Array(256).fill(0);\n    \n    // Count frequency of each byte value\n    for (let i = 0; i < data.length; i++) {\n      counts[data[i]]++;\n    }\n    \n    // Calculate entropy\n    let entropy = 0;\n    for (let i = 0; i < 256; i++) {\n      if (counts[i] > 0) {\n        const p = counts[i] / data.length;\n        entropy -= p * Math.log2(p);\n      }\n    }\n    \n    return entropy;\n  }\n\n  /**\n   * Auto-select compression strategy based on data characteristics\n   */\n  private autoCompress(data: Uint8Array): { strategy: string, entropyScore: number } {\n    // For very large files, use block-based compression regardless\n    if (data.length > 5 * 1024 * 1024) { // >5MB\n      return { strategy: 'dictionary', entropyScore: 7.0 };\n    }\n\n    // Calculate entropy for strategy selection\n    const entropy = this.calculateEntropy(data);\n    \n    // Analyze data characteristics\n    const stats = this.analyzeBlock(data);\n    \n    // Create a scoring system for each strategy\n    const scores = {\n      pattern: 0,\n      sequential: 0,\n      dictionary: 0,\n      spectral: 0\n    };\n    \n    // Score boost for obvious patterns\n    if (stats.isConstant) scores.pattern += 100;\n    if (stats.hasPattern) scores.pattern += 50;\n    \n    // Sequences are often arithmetic progressions\n    if (stats.hasSequence) scores.sequential += 70;\n    \n    // Text and structured data works well with dictionary compression\n    if (stats.isTextLike) scores.dictionary += 60;\n    \n    // Entropy-based scoring\n    if (entropy < 3.0) {\n      // Very low entropy - highly compressible with patterns\n      scores.pattern += 40;\n    } else if (entropy < 5.0) {\n      // Medium entropy - could be sequential or dictionary\n      scores.sequential += 30;\n      scores.dictionary += 20;\n    } else if (entropy < 7.0) {\n      // Higher entropy - dictionary is often best\n      scores.dictionary += 40;\n    } else {\n      // Very high entropy - spectral or just store as is\n      scores.spectral += 50;\n    }\n    \n    // Secondary scoring adjustments based on data size\n    if (data.length < 1024) {\n      // For very small data, pattern is often most efficient\n      scores.pattern += 15;\n    } else if (data.length > 100 * 1024) {\n      // For larger data, dictionary offers good compression\n      scores.dictionary += 20;\n    }\n    \n    // Analyze for periodic patterns that might benefit from spectral compression\n    if (stats.hasSpectralPattern) {\n      scores.spectral += 40;\n    }\n    \n    // Find the highest scoring strategy\n    let bestStrategy = 'dictionary'; // Default\n    let bestScore = scores.dictionary;\n    \n    if (scores.pattern > bestScore) {\n      bestStrategy = 'pattern';\n      bestScore = scores.pattern;\n    }\n    \n    if (scores.sequential > bestScore) {\n      bestStrategy = 'sequential';\n      bestScore = scores.sequential;\n    }\n    \n    if (scores.spectral > bestScore) {\n      bestStrategy = 'spectral';\n      bestScore = scores.spectral;\n    }\n    \n    // Extra check - if we're dealing with high-entropy data and no clear winner,\n    // spectral might be the best option\n    if (entropy > 7.0 && bestScore < 30) {\n      bestStrategy = 'spectral';\n    }\n    \n    // Debug log for strategy selection\n    console.debug(`Selected strategy: ${bestStrategy} (entropy: ${entropy.toFixed(2)}, scores: `, \n                scores, `, isConstant: ${stats.isConstant}, hasPattern: ${stats.hasPattern}, hasSequence: ${stats.hasSequence}, isTextLike: ${stats.isTextLike})`);\n    \n    return { strategy: bestStrategy, entropyScore: entropy };\n  }\n\n  /**\n   * Analyze data block for compression strategy selection\n   */\n  private analyzeBlock(data: Uint8Array): {\n    entropy: number,\n    isConstant: boolean,\n    hasPattern: boolean,\n    hasSequence: boolean,\n    hasSpectralPattern: boolean,\n    isTextLike: boolean\n  } {\n    const stats = {\n      entropy: this.calculateEntropy(data),\n      isConstant: true,\n      hasPattern: false,\n      hasSequence: false,\n      hasSpectralPattern: false,\n      isTextLike: false,\n    };\n    \n    // Check if all bytes are the same (constant)\n    if (data.length > 0) {\n      const firstByte = data[0];\n      for (let i = 1; i < data.length; i++) {\n        if (data[i] !== firstByte) {\n          stats.isConstant = false;\n          break;\n        }\n      }\n    }\n    \n    // Check for repeating patterns\n    if (!stats.isConstant && data.length >= 8) {\n      stats.hasPattern = this.detectPattern(data);\n    }\n    \n    // Check for sequential patterns\n    if (!stats.isConstant && !stats.hasPattern && data.length >= 8) {\n      stats.hasSequence = this.detectSequence(data);\n    }\n    \n    // Check for spectral patterns (sine waves, etc.)\n    if (!stats.isConstant && data.length >= 16) {\n      stats.hasSpectralPattern = this.detectSpectralPattern(data);\n    }\n    \n    // Check if data appears to be text\n    if (data.length > 0) {\n      stats.isTextLike = this.isTextLike(data);\n    }\n    \n    return stats;\n  }\n\n  /**\n   * Detect repeating patterns in data\n   */\n  private detectPattern(data: Uint8Array): boolean {\n    // Basic pattern detection algorithm\n    if (data.length < 8) return false;\n    \n    // Sample the data for large arrays to improve performance\n    const MAX_SAMPLE_SIZE = 4096;\n    const sampleInterval = data.length > MAX_SAMPLE_SIZE ? Math.ceil(data.length / MAX_SAMPLE_SIZE) : 1;\n    \n    // Check if all bytes are the same (sampling for large data)\n    const firstByte = data[0];\n    let allSame = true;\n    const sampleSize = Math.min(64, data.length);\n    \n    for (let i = 1; i < sampleSize; i++) {\n      const pos = i * sampleInterval < data.length ? i * sampleInterval : i;\n      if (data[pos] !== firstByte) {\n        allSame = false;\n        break;\n      }\n    }\n    \n    // Quick exit for constant data\n    if (allSame && sampleSize >= 16) return true;\n    \n    // Check runs first as they're common and efficiently compressed\n    // Check for long runs of the same byte (at least 15% of total size or 8 bytes)\n    let runThreshold = Math.max(8, Math.floor(data.length * 0.15));\n    let currentByte = data[0];\n    let runLength = 1;\n    let maxRunLength = 1;\n    let totalRunLength = 0;\n    \n    // Sample the data for large arrays\n    const runCheckLimit = Math.min(data.length, 10000);\n    \n    for (let i = 1; i < runCheckLimit; i++) {\n      if (data[i] === currentByte) {\n        runLength++;\n      } else {\n        if (runLength >= 4) {\n          totalRunLength += runLength;\n        }\n        currentByte = data[i];\n        runLength = 1;\n      }\n      \n      if (runLength > maxRunLength) {\n        maxRunLength = runLength;\n      }\n    }\n    \n    // If we have a significant portion as runs, it's a good candidate for pattern compression\n    const runRatio = totalRunLength / Math.min(data.length, runCheckLimit);\n    \n    // If we have runs of 8+ bytes, or total runs are >20% of the data, consider it a pattern\n    if (maxRunLength >= runThreshold || runRatio > 0.2) return true;\n    \n    // Check for repeating patterns (up to 8 bytes)\n    // Only check beginning portion of large files\n    const patternCheckLimit = Math.min(data.length, 1024); \n    \n    for (let patternLength = 2; patternLength <= 8; patternLength++) {\n      // Skip patterns that don't divide evenly into the check length (improves performance)\n      if (patternCheckLimit % patternLength !== 0 && patternLength > 4) continue;\n      \n      let isPattern = true;\n      let matchCount = 0;\n      const minMatches = Math.min(8, Math.floor(patternCheckLimit / patternLength));\n      \n      for (let i = patternLength; i < patternCheckLimit; i++) {\n        if (data[i] !== data[i % patternLength]) {\n          isPattern = false;\n          break;\n        }\n        \n        if (i % patternLength === 0) {\n          matchCount++;\n          if (matchCount >= minMatches) break;\n        }\n      }\n      \n      if (isPattern && matchCount >= minMatches) return true;\n    }\n    \n    return false;\n  }\n\n  /**\n   * Detect sequential patterns in data\n   */\n  private detectSequence(data: Uint8Array): boolean {\n    if (data.length < 8) return false;\n    \n    // Limit the check for large files\n    const MAX_CHECK = 256;\n    const checkSize = Math.min(MAX_CHECK, data.length);\n    \n    // For large files, sample at regular intervals\n    const samplingRate = data.length > 1000 ? Math.floor(data.length / 100) : 1;\n    \n    // Check for arithmetic sequence (constant difference)\n    const diffs = [];\n    \n    // Collect differences, either sequential or sampled\n    if (samplingRate > 1) {\n      // Sampling approach for large files\n      for (let i = samplingRate; i < checkSize; i += samplingRate) {\n        diffs.push((data[i] - data[i-samplingRate] + 256) % 256);\n      }\n    } else {\n      // Regular sequential approach for smaller files\n      for (let i = 1; i < checkSize; i++) {\n        diffs.push((data[i] - data[i-1] + 256) % 256);\n      }\n    }\n    \n    // Empty array check (should never happen but as safety)\n    if (diffs.length === 0) return false;\n    \n    // Check if all differences are the same\n    const firstDiff = diffs[0];\n    \n    // For long sequences, we allow a small error rate\n    if (diffs.length > 32) {\n      // Count matching diffs\n      const matches = diffs.filter(diff => diff === firstDiff).length;\n      const matchRatio = matches / diffs.length;\n      \n      // If >90% of differences match, consider it a sequence\n      return matchRatio > 0.9;\n    } else {\n      // For shorter sequences, require exact match\n      return diffs.every(diff => diff === firstDiff);\n    }\n  }\n\n  /**\n   * Detect spectral patterns in data\n   */\n  private detectSpectralPattern(data: Uint8Array): boolean {\n    // Simplified spectral analysis\n    // Check for oscillating patterns in the data\n    if (data.length < 16) return false;\n    \n    // Look for sinusoidal-like patterns\n    // Compute first and second derivatives\n    const firstDerivative = [];\n    for (let i = 1; i < data.length; i++) {\n      firstDerivative.push((data[i] - data[i-1] + 256) % 256);\n    }\n    \n    // Check for sign changes in the first derivative\n    // which would indicate peaks and valleys\n    let signChanges = 0;\n    let lastSign = firstDerivative[0] > 0 ? 1 : (firstDerivative[0] < 0 ? -1 : 0);\n    \n    for (let i = 1; i < firstDerivative.length; i++) {\n      const currentDiff = firstDerivative[i];\n      const currentSign = currentDiff > 0 ? 1 : (currentDiff < 0 ? -1 : 0);\n      \n      if (currentSign !== 0 && lastSign !== 0 && currentSign !== lastSign) {\n        signChanges++;\n      }\n      \n      if (currentSign !== 0) {\n        lastSign = currentSign;\n      }\n    }\n    \n    // If we have several sign changes, it might be a sinusoidal pattern\n    return signChanges >= 4;\n  }\n\n  /**\n   * Check if data is likely text\n   */\n  private isTextLike(data: Uint8Array): boolean {\n    if (data.length === 0) return false;\n    \n    let textChars = 0;\n    let wordChars = 0;\n    let spaces = 0;\n    const sampleSize = Math.min(data.length, 100);\n    \n    for (let i = 0; i < sampleSize; i++) {\n      // Check for ASCII text range (printable characters)\n      if (data[i] >= 32 && data[i] <= 126) {\n        textChars++;\n        \n        // Count word characters (a-z, A-Z) and spaces\n        if ((data[i] >= 65 && data[i] <= 90) || (data[i] >= 97 && data[i] <= 122)) {\n          wordChars++;\n        } else if (data[i] === 32) {\n          spaces++;\n        }\n      }\n    }\n    \n    // More sophisticated text detection - high proportion of letters and spaces\n    const textRatio = textChars / sampleSize;\n    const wordRatio = (wordChars + spaces) / sampleSize;\n    \n    return textRatio > 0.7 && wordRatio > 0.4;\n  }\n  \n  /**\n   * Pattern-based compression strategy (improved RLE)\n   */\n  private patternCompress(data: Uint8Array): Uint8Array {\n    if (data.length === 0) return new Uint8Array(0);\n    \n    // Check if all bytes are the same\n    let isConstant = true;\n    const firstByte = data[0];\n    \n    for (let i = 1; i < data.length; i++) {\n      if (data[i] !== firstByte) {\n        isConstant = false;\n        break;\n      }\n    }\n    \n    // Special case: constant data (all bytes are the same)\n    if (isConstant) {\n      const result = new Uint8Array(3);\n      result[0] = 0xC0; // Marker for constant data\n      result[1] = firstByte; // The constant value\n      result[2] = Math.min(255, data.length); // Length (up to 255)\n      return result;\n    }\n    \n    // Check for repeating pattern\n    let patternFound = false;\n    let pattern: number[] = [];\n    \n    // Try to find a repeating pattern (up to 16 bytes)\n    for (let patternLength = 2; patternLength <= 16; patternLength++) {\n      if (data.length < patternLength * 2) continue;\n      \n      let isPattern = true;\n      pattern = Array.from(data.slice(0, patternLength));\n      \n      for (let i = patternLength; i < data.length; i++) {\n        if (data[i] !== pattern[i % patternLength]) {\n          isPattern = false;\n          break;\n        }\n      }\n      \n      if (isPattern) {\n        patternFound = true;\n        break;\n      }\n    }\n    \n    // If we found a repeating pattern, encode efficiently\n    if (patternFound && pattern.length > 0 && pattern.length <= 16) {\n      const result = new Uint8Array(3 + pattern.length);\n      result[0] = 0xC1; // Marker for repeating pattern\n      result[1] = pattern.length; // Pattern length\n      result[2] = Math.floor(data.length / pattern.length); // Repeat count\n      \n      // Store the pattern\n      for (let i = 0; i < pattern.length; i++) {\n        result[3 + i] = pattern[i];\n      }\n      \n      return result;\n    }\n    \n    // General RLE compression\n    const result = [];\n    let i = 0;\n    \n    // Header byte indicating RLE compression\n    result.push(0xF0); // Marker for RLE compression\n    \n    while (i < data.length) {\n      // Look for runs of the same byte\n      let runLength = 1;\n      const currentByte = data[i];\n      \n      while (i + runLength < data.length && data[i + runLength] === currentByte && runLength < 255) {\n        runLength++;\n      }\n      \n      if (runLength >= 4) {\n        // Encode as a run\n        result.push(0xFF); // Run marker\n        result.push(runLength); // Run length\n        result.push(currentByte); // Byte value\n        i += runLength;\n      } else {\n        // Check for a short literal run\n        let litLength = 1;\n        let maxLitLength = Math.min(127, data.length - i);\n        \n        while (litLength < maxLitLength) {\n          // Look ahead to see if we'd benefit from a run\n          const nextByte = data[i + litLength];\n          let nextRunLength = 1;\n          \n          while (i + litLength + nextRunLength < data.length && \n                data[i + litLength + nextRunLength] === nextByte && \n                nextRunLength < 255) {\n            nextRunLength++;\n          }\n          \n          // If we have a good run coming up, stop the literal sequence\n          if (nextRunLength >= 4) break;\n          \n          litLength++;\n        }\n        \n        // Encode the literal sequence\n        result.push(litLength - 1); // Literal length (0-127 means 1-128 bytes)\n        for (let j = 0; j < litLength; j++) {\n          result.push(data[i + j]);\n        }\n        \n        i += litLength;\n      }\n    }\n    \n    return new Uint8Array(result);\n  }\n  \n  /**\n   * Sequential compression strategy\n   */\n  private sequentialCompress(data: Uint8Array): Uint8Array {\n    if (data.length < 4) return data; // Too small to compress\n    \n    // Check if data follows a simple arithmetic sequence\n    const diffs = [];\n    for (let i = 1; i < Math.min(16, data.length); i++) {\n      diffs.push((data[i] - data[i-1] + 256) % 256); // Handle wrap around\n    }\n    \n    const firstDiff = diffs[0];\n    const isArithmetic = diffs.every(diff => diff === firstDiff);\n    \n    if (isArithmetic) {\n      // Arithmetic sequence: store [marker, start, difference, length (2 bytes)]\n      const result = new Uint8Array(5);\n      result[0] = 0xF1; // Marker for arithmetic sequence\n      result[1] = data[0]; // Start value\n      result[2] = firstDiff; // Common difference\n      result[3] = data.length & 0xFF; // Length (low byte)\n      result[4] = (data.length >> 8) & 0xFF; // Length (high byte)\n      return result;\n    }\n    \n    // Check for modulo pattern (i % 256, commonly used in test data)\n    let isModulo = true;\n    for (let i = 0; i < Math.min(256, data.length); i++) {\n      if (data[i] !== (i % 256)) {\n        isModulo = false;\n        break;\n      }\n    }\n    \n    if (isModulo) {\n      // Modulo sequence: store [marker, length (2 bytes)]\n      const result = new Uint8Array(3);\n      result[0] = 0xF2; // Marker for modulo sequence\n      result[1] = data.length & 0xFF; // Length (low byte)\n      result[2] = (data.length >> 8) & 0xFF; // Length (high byte)\n      return result;\n    }\n    \n    // If not a simple sequence, fall back to patterns or dictionary\n    return this.patternCompress(data);\n  }\n  \n  /**\n   * Spectral compression for high-entropy data\n   */\n  private spectralCompress(data: Uint8Array): Uint8Array {\n    // For high-entropy random data, just store with minimal overhead\n    if (this.calculateEntropy(data) > 7.0) {\n      const result = new Uint8Array(data.length + 3);\n      result[0] = 0xF3; // Marker for high-entropy data\n      result[1] = data.length & 0xFF; // Length (low byte)\n      result[2] = (data.length >> 8) & 0xFF; // Length (high byte)\n      result.set(data, 3);\n      return result;\n    }\n    \n    // For spectrally compressible data (oscillating patterns)\n    // Attempt basic Fourier-inspired encoding\n    \n    // Find min and max values for normalization\n    let min = 255;\n    let max = 0;\n    \n    for (let i = 0; i < data.length; i++) {\n      if (data[i] < min) min = data[i];\n      if (data[i] > max) max = data[i];\n    }\n    \n    // If the range is small, use a simplified encoding\n    if (max - min <= 32) {\n      const result = [];\n      result.push(0xF4); // Marker for range-compressed data\n      result.push(min); // Minimum value\n      result.push(max); // Maximum value\n      \n      // Pack multiple values into each byte when possible\n      const bitsRequired = Math.ceil(Math.log2(max - min + 1));\n      const valuesPerByte = Math.floor(8 / bitsRequired);\n      \n      if (valuesPerByte >= 2) {\n        result.push(bitsRequired); // Bits per value\n        \n        let currentByte = 0;\n        let bitsFilled = 0;\n        \n        for (let i = 0; i < data.length; i++) {\n          // Normalize to 0-(max-min) range\n          const normalizedValue = data[i] - min;\n          \n          // Pack into current byte\n          currentByte |= (normalizedValue << bitsFilled);\n          bitsFilled += bitsRequired;\n          \n          // If byte is full, store it and start a new one\n          if (bitsFilled >= 8) {\n            result.push(currentByte & 0xFF);\n            currentByte = normalizedValue >> (bitsRequired - (bitsFilled - 8));\n            bitsFilled = bitsFilled - 8;\n          }\n        }\n        \n        // Store any remaining bits\n        if (bitsFilled > 0) {\n          result.push(currentByte & 0xFF);\n        }\n        \n        return new Uint8Array(result);\n      }\n    }\n    \n    // Fall back to delta encoding for other data\n    const result = [];\n    result.push(0xF5); // Marker for delta encoding\n    result.push(data[0]); // Store first byte directly\n    \n    // Store deltas between consecutive bytes\n    for (let i = 1; i < data.length; i++) {\n      // Calculate delta (-128 to 127 range)\n      let delta = data[i] - data[i-1];\n      if (delta < -128) delta += 256;\n      if (delta > 127) delta -= 256;\n      \n      // Convert to unsigned byte representation\n      result.push(delta & 0xFF);\n    }\n    \n    return new Uint8Array(result);\n  }\n  \n  /**\n   * Dictionary-based compression with Huffman coding\n   */\n  private dictionaryCompress(data: Uint8Array): Uint8Array {\n    if (data.length < 8) return data; // Too small to compress\n    \n    // For very large files, sample the data instead of scanning the whole file\n    const MAX_DICT_SCAN = 100000; // Maximum bytes to scan for dictionary building\n    const dictScanSize = Math.min(data.length, MAX_DICT_SCAN);\n    \n    // For extremely large files, use a different sampling strategy\n    let sampledData = data;\n    let samplingRate = 1;\n    \n    if (data.length > MAX_DICT_SCAN) {\n      samplingRate = Math.ceil(data.length / MAX_DICT_SCAN);\n      \n      // Create a representative sample that includes:\n      // 1. The beginning of the file (tends to have important patterns)\n      // 2. Regular samples throughout\n      // 3. The end of the file (often contains important patterns too)\n      const sampleSize = Math.min(MAX_DICT_SCAN, Math.ceil(data.length / samplingRate) + 1000);\n      sampledData = new Uint8Array(sampleSize);\n      \n      // Copy first 1000 bytes directly\n      const headSize = Math.min(1000, data.length);\n      for (let i = 0; i < headSize; i++) {\n        sampledData[i] = data[i];\n      }\n      \n      // Sample from the rest of the file\n      let samplePos = headSize;\n      for (let i = 1000; i < data.length - 1000; i += samplingRate) {\n        if (samplePos < sampledData.length) {\n          sampledData[samplePos++] = data[i];\n        }\n      }\n      \n      // Copy last 1000 bytes (or whatever space remains)\n      const tailStart = Math.max(0, data.length - 1000);\n      let remainingSpace = sampledData.length - samplePos;\n      \n      for (let i = 0; i < remainingSpace && tailStart + i < data.length; i++) {\n        sampledData[samplePos++] = data[tailStart + i];\n      }\n    }\n    \n    // Build frequency table for common bytes\n    const freqTable = new Array(256).fill(0);\n    for (let i = 0; i < dictScanSize; i++) {\n      freqTable[data[i]]++;\n    }\n    \n    // First pass: find frequent byte pairs for the dictionary\n    const pairs = new Map<number, number>(); // Maps pair hash to frequency\n    \n    // Only scan the sampled data for pairs, not the entire file for large files\n    for (let i = 0; i < sampledData.length - 1; i++) {\n      const pairHash = (sampledData[i] << 8) | sampledData[i + 1];\n      pairs.set(pairHash, (pairs.get(pairHash) || 0) + 1);\n    }\n    \n    // Find most frequent pairs - increase max pairs for larger files\n    const maxPairs = data.length > 100000 ? 24 : 16; \n    \n    const pairsArray = Array.from(pairs.entries());\n    const sortedPairs = pairsArray\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, maxPairs)\n      .map(entry => entry[0]);\n    \n    if (sortedPairs.length === 0) {\n      // No repeating pairs - try simpler RLE compression\n      return this.patternCompress(data);\n    }\n    \n    // Create dictionary\n    const dictionary = sortedPairs.map(pairHash => {\n      return [pairHash >> 8, pairHash & 0xFF];\n    });\n    \n    // Estimate compression ratio before fully compressing\n    // This avoids wasteful work for incompressible data\n    if (data.length > 10000) {\n      // Sample first 10K to estimate compression ratio\n      const sampleCompressed = [];\n      let i = 0;\n      const sampleLimit = Math.min(10000, data.length);\n      \n      while (i < sampleLimit) {\n        if (i < sampleLimit - 1) {\n          const pairHash = (data[i] << 8) | data[i + 1];\n          const dictIndex = sortedPairs.indexOf(pairHash);\n          \n          if (dictIndex >= 0) {\n            // Dictionary reference\n            sampleCompressed.push(0xE0 | dictIndex);\n            i += 2;\n            continue;\n          }\n        }\n        \n        // Literal byte\n        sampleCompressed.push(data[i]);\n        i++;\n      }\n      \n      // Add dictionary overhead\n      const dictionarySize = 2 + (dictionary.length * 2);\n      const estimatedRatio = sampleLimit / (sampleCompressed.length + dictionarySize);\n      \n      // If compression ratio is poor, fall back to pattern compression or raw storage\n      if (estimatedRatio < 1.05) {\n        // For very poor compression, just store raw\n        if (estimatedRatio < 1.01) {\n          const result = new Uint8Array(data.length + 3);\n          result[0] = 0xF7; // Marker for uncompressed data\n          result[1] = data.length & 0xFF; // Length (low byte)\n          result[2] = (data.length >> 8) & 0xFF; // Length (high byte)\n          result.set(data, 3);\n          return result;\n        } else {\n          return this.patternCompress(data);\n        }\n      }\n    }\n    \n    // Compress data using the dictionary\n    const compressed = [];\n    compressed.push(0xF6); // Marker for dictionary compression\n    compressed.push(dictionary.length); // Dictionary size\n    \n    // Store dictionary\n    for (const [byte1, byte2] of dictionary) {\n      compressed.push(byte1);\n      compressed.push(byte2);\n    }\n    \n    // Compress data directly without run tracking\n    // (future improvement: implement run length encoding for literals)\n    \n    // Compress data\n    let i = 0;\n    while (i < data.length) {\n      if (i < data.length - 1) {\n        const pairHash = (data[i] << 8) | data[i + 1];\n        const dictIndex = sortedPairs.indexOf(pairHash);\n        \n        if (dictIndex >= 0) {\n          // Dictionary reference\n          compressed.push(0xE0 | dictIndex); // Use 0xE0-0xEF for dictionary refs\n          i += 2; // Skip the pair\n          continue;\n        }\n      }\n      \n      // Literal byte\n      compressed.push(data[i]);\n      i++;\n    }\n    \n    // If our compression isn't effective, fall back to the original data\n    if (compressed.length >= data.length) {\n      // Just store the original data with a minimal header\n      const result = new Uint8Array(data.length + 3);\n      result[0] = 0xF7; // Marker for uncompressed data\n      result[1] = data.length & 0xFF; // Length (low byte)\n      result[2] = (data.length >> 8) & 0xFF; // Length (high byte)\n      result.set(data, 3);\n      return result;\n    }\n    \n    return new Uint8Array(compressed);\n  }\n  \n  /**\n   * Real compression function with strategy selection and block-based processing\n   */\n  private realCompress(\n    strategies: any,\n    data: Uint8Array, \n    options: CompressionOptions = {}\n  ): Promise<{ \n    compressedData: Uint8Array, \n    compressionRatio: number, \n    strategy: string,\n    originalSize: number,\n    compressedSize: number,\n    compressionTime: number\n  }> {\n    return new Promise((resolve) => {\n      // Start timer\n      const startTime = performance.now();\n      \n      try {\n        // Determine compression strategy to use\n        let strategyToUse = options.strategy || 'auto';\n        let autoSelectedStrategy = '';\n        \n        if (strategyToUse === 'auto') {\n          // Auto-select the best strategy for the data\n          const autoResult = this.autoCompress(data);\n          autoSelectedStrategy = autoResult.strategy;\n          strategyToUse = autoSelectedStrategy;\n        }\n        \n        // Determine if we should use block-based compression\n        const useBlocks = options.useBlocks !== false && data.length > 8192; // Default to block compression for data > 8KB\n        \n        // Apply the selected compression strategy\n        let compressedData: Uint8Array;\n        \n        if (useBlocks) {\n          // Block-based compression for large files\n          compressedData = this.compressWithBlocks(data, strategyToUse, strategies);\n        } else {\n          // Regular compression for smaller files\n          switch (strategyToUse) {\n            case 'pattern':\n              compressedData = strategies.pattern(data);\n              break;\n            case 'sequential':\n              compressedData = strategies.sequential(data);\n              break;\n            case 'spectral':\n              compressedData = strategies.spectral(data);\n              break;\n            case 'dictionary':\n              compressedData = strategies.dictionary(data);\n              break;\n            default:\n              // Fall back to auto-selection\n              const bestStrategy = strategies.auto(data).strategy;\n              switch (bestStrategy) {\n                case 'pattern':\n                  compressedData = strategies.pattern(data);\n                  break;\n                case 'sequential':\n                  compressedData = strategies.sequential(data);\n                  break;\n                case 'spectral':\n                  compressedData = strategies.spectral(data);\n                  break;\n                case 'dictionary':\n                  compressedData = strategies.dictionary(data);\n                  break;\n                default:\n                  compressedData = strategies.dictionary(data);\n                  strategyToUse = 'dictionary';\n              }\n          }\n        }\n        \n        // Calculate compression ratio and time\n        const compressionRatio = data.length / compressedData.length;\n        const compressionTime = performance.now() - startTime;\n        \n        // Prepare result object\n        resolve({\n          compressedData,\n          compressionRatio,\n          strategy: strategyToUse,\n          originalSize: data.length,\n          compressedSize: compressedData.length,\n          compressionTime\n        });\n      } catch (error) {\n        console.error('Compression error:', error);\n        \n        // In case of error, throw it instead of returning uncompressed data\n        const errorMessage = error instanceof Error \n          ? error.message \n          : String(error);\n        throw new Error(`Compression failed: ${errorMessage || 'Unknown error'}`);\n      }\n    });\n  }\n  \n  /**\n   * Block-based compression for large data\n   * Splits data into blocks and compresses each with potentially different strategies\n   */\n  private compressWithBlocks(\n    data: Uint8Array, \n    defaultStrategy: string,\n    strategies: any\n  ): Uint8Array {\n    // Size for each block - adaptive based on total size\n    let blockSize: number;\n    \n    // Choose block size based on data size\n    if (data.length > 100 * 1024 * 1024) { // >100MB\n      blockSize = 1024 * 1024; // 1MB blocks for very large files\n    } else if (data.length > 10 * 1024 * 1024) { // >10MB\n      blockSize = 256 * 1024; // 256KB blocks for large files\n    } else if (data.length > 1024 * 1024) { // >1MB\n      blockSize = 64 * 1024; // 64KB blocks for medium files\n    } else if (data.length > 100 * 1024) { // >100KB\n      blockSize = 32 * 1024; // 32KB for small-medium files\n    } else {\n      blockSize = 16 * 1024; // 16KB for small files\n    }\n    \n    // Calculate number of blocks\n    const numBlocks = Math.ceil(data.length / blockSize);\n    \n    // Limit number of blocks to avoid excessive memory usage\n    const MAX_BLOCKS = 1000;\n    if (numBlocks > MAX_BLOCKS) {\n      // Recalculate block size to stay under MAX_BLOCKS\n      blockSize = Math.ceil(data.length / MAX_BLOCKS);\n      console.debug(`Adjusted block size to ${blockSize} bytes to limit block count`);\n    }\n    \n    // Prepare storage arrays\n    const blocks: Uint8Array[] = [];\n    const blockStrategies: string[] = [];\n    const blockSizes: number[] = [];\n    \n    // Initial blocks array will contain a header\n    // Format: [0xB1, block count (2 bytes), block size (4 bytes)]\n    // Extended to 4 bytes for block size to support larger blocks\n    const header = new Uint8Array(7);\n    header[0] = 0xB1; // Block marker\n    header[1] = numBlocks & 0xFF; // Block count low byte\n    header[2] = (numBlocks >> 8) & 0xFF; // Block count high byte\n    header[3] = blockSize & 0xFF; // Block size byte 1 (LSB)\n    header[4] = (blockSize >> 8) & 0xFF; // Block size byte 2\n    header[5] = (blockSize >> 16) & 0xFF; // Block size byte 3\n    header[6] = (blockSize >> 24) & 0xFF; // Block size byte 4 (MSB)\n    blocks.push(header);\n    \n    // Strategy diversity tracking to log compression effectiveness\n    const strategyUsage: { [key: string]: number } = {\n      'pattern': 0,\n      'sequential': 0,\n      'spectral': 0,\n      'dictionary': 0\n    };\n    \n    // Process each block\n    for (let i = 0; i < numBlocks; i++) {\n      const blockStart = i * blockSize;\n      const blockEnd = Math.min(blockStart + blockSize, data.length);\n      const block = data.slice(blockStart, blockEnd);\n      \n      // For extremely large files, limit analysis to improve performance\n      const shouldAnalyze = data.length < 50 * 1024 * 1024 || // Always analyze if <50MB\n                            i % 5 === 0 || // Sample every 5th block for large files\n                            i < 10 || // Always analyze the first few blocks\n                            i >= numBlocks - 5; // Always analyze the last few blocks\n      \n      // Analyze this block for optimal strategy if needed\n      let blockStrategy = defaultStrategy;\n      if (defaultStrategy === 'auto' && shouldAnalyze) {\n        blockStrategy = this.autoCompress(block).strategy;\n      } else if (defaultStrategy === 'auto') {\n        // For skipped blocks in very large files, use dictionary as safe default\n        blockStrategy = 'dictionary';\n      }\n      \n      // Compress block\n      let compressedBlock: Uint8Array;\n      try {\n        switch (blockStrategy) {\n          case 'pattern':\n            compressedBlock = strategies.pattern(block);\n            break;\n          case 'sequential':\n            compressedBlock = strategies.sequential(block);\n            break;\n          case 'spectral':\n            compressedBlock = strategies.spectral(block);\n            break;\n          case 'dictionary':\n            compressedBlock = strategies.dictionary(block);\n            break;\n          default:\n            compressedBlock = strategies.dictionary(block);\n            blockStrategy = 'dictionary';\n        }\n      } catch (error) {\n        // Fallback in case of any compression error\n        console.error(`Error compressing block ${i}, falling back to dictionary:`, error);\n        compressedBlock = strategies.dictionary(block);\n        blockStrategy = 'dictionary';\n      }\n      \n      // Track strategy usage\n      strategyUsage[blockStrategy]++;\n      \n      // Check if compression is beneficial for this block\n      if (compressedBlock.length >= block.length) {\n        // If compression didn't help, store block uncompressed\n        compressedBlock = new Uint8Array(block.length + 3);\n        compressedBlock[0] = 0xF7; // Marker for uncompressed data\n        compressedBlock[1] = block.length & 0xFF; // Length (low byte)\n        compressedBlock[2] = (block.length >> 8) & 0xFF; // Length (high byte)\n        compressedBlock.set(block, 3);\n        blockStrategy = 'raw';\n        \n        // Update tracking\n        if (!strategyUsage['raw']) strategyUsage['raw'] = 0;\n        strategyUsage['raw']++;\n      }\n      \n      // Create block header [strategy id (1 byte), size (4 bytes for larger blocks)]\n      const blockHeader = new Uint8Array(5);\n      const strategyId = this.getStrategyId(blockStrategy);\n      blockHeader[0] = strategyId;\n      blockHeader[1] = compressedBlock.length & 0xFF; // Size byte 1 (LSB)\n      blockHeader[2] = (compressedBlock.length >> 8) & 0xFF; // Size byte 2\n      blockHeader[3] = (compressedBlock.length >> 16) & 0xFF; // Size byte 3\n      blockHeader[4] = (compressedBlock.length >> 24) & 0xFF; // Size byte 4 (MSB)\n      \n      // Store block and metadata\n      blocks.push(blockHeader);\n      blocks.push(compressedBlock);\n      blockStrategies.push(blockStrategy);\n      blockSizes.push(compressedBlock.length);\n      \n      // Log progress for large files\n      if (numBlocks > 20 && (i === 0 || i === numBlocks - 1 || i % 10 === 0)) {\n        console.debug(`Block ${i+1}/${numBlocks} compressed`);\n      }\n    }\n    \n    // Log strategy usage stats\n    console.debug('Block compression strategy usage:', strategyUsage);\n    \n    // Calculate total size needed\n    let totalSize = 7; // Header size (increased to 7 bytes)\n    for (let i = 0; i < numBlocks; i++) {\n      totalSize += 5; // Block header size (increased to 5 bytes)\n      totalSize += blockSizes[i]; // Block data size\n    }\n    \n    // Combine all blocks\n    const result = new Uint8Array(totalSize);\n    let offset = 0;\n    \n    // Copy all blocks to result\n    for (const block of blocks) {\n      result.set(block, offset);\n      offset += block.length;\n    }\n    \n    // Log overall compression effectiveness\n    const originalSize = data.length;\n    const compressedSize = result.length;\n    const compressionRatio = originalSize / compressedSize;\n    console.debug(`Block compression complete: ${originalSize}  ${compressedSize} bytes (${compressionRatio.toFixed(2)}x ratio)`);\n    \n    return result;\n  }\n  \n  /**\n   * Convert strategy name to ID for block headers\n   */\n  private getStrategyId(strategy: string): number {\n    switch (strategy) {\n      case 'pattern': return 1;\n      case 'sequential': return 2;\n      case 'spectral': return 3;\n      case 'dictionary': return 4;\n      case 'raw': return 5; // Uncompressed data\n      default: return 0; // Auto or unknown\n    }\n  }\n  \n  /**\n   * Real decompression implementation with block support\n   */\n  private realDecompress(compressedData: Uint8Array): Promise<Uint8Array> {\n    return new Promise((resolve, reject) => {\n      try {\n        if (compressedData.length === 0) {\n          return resolve(new Uint8Array(0));\n        }\n        \n        // Check marker byte to determine compression type\n        const marker = compressedData[0];\n        \n        // Handle block-based compression first\n        if (marker === 0xB1) {\n          return this.decompressBlocks(compressedData).then(resolve).catch(reject);\n        }\n        \n        switch (marker) {\n          case 0xC0: // Constant data\n            if (compressedData.length < 3) {\n              return reject(new Error('Invalid constant data format'));\n            }\n            \n            const value = compressedData[1];\n            const length = compressedData[2];\n            \n            const constantResult = new Uint8Array(length);\n            constantResult.fill(value);\n            return resolve(constantResult);\n            \n          case 0xC1: // Repeating pattern\n            if (compressedData.length < 3) {\n              return reject(new Error('Invalid pattern data format'));\n            }\n            \n            const patternLength = compressedData[1];\n            const repeatCount = compressedData[2];\n            \n            if (compressedData.length < 3 + patternLength) {\n              return reject(new Error('Invalid pattern data length'));\n            }\n            \n            const pattern = compressedData.slice(3, 3 + patternLength);\n            const patternResult = new Uint8Array(patternLength * repeatCount);\n            \n            for (let i = 0; i < repeatCount; i++) {\n              patternResult.set(pattern, i * patternLength);\n            }\n            \n            return resolve(patternResult);\n            \n          case 0xF0: // RLE compression\n            {\n              const result = [];\n              let i = 1;\n              \n              while (i < compressedData.length) {\n                if (compressedData[i] === 0xFF && i + 2 < compressedData.length) {\n                  // Run\n                  const count = compressedData[i + 1];\n                  const value = compressedData[i + 2];\n                  for (let j = 0; j < count; j++) {\n                    result.push(value);\n                  }\n                  i += 3;\n                } else if (compressedData[i] < 128) {\n                  // Literal sequence\n                  const length = compressedData[i] + 1;\n                  for (let j = 0; j < length && i + 1 + j < compressedData.length; j++) {\n                    result.push(compressedData[i + 1 + j]);\n                  }\n                  i += length + 1;\n                } else {\n                  // Unknown marker, treat as literal\n                  result.push(compressedData[i]);\n                  i++;\n                }\n              }\n              \n              return resolve(new Uint8Array(result));\n            }\n            \n          case 0xF1: // Arithmetic sequence\n            if (compressedData.length < 5) {\n              return reject(new Error('Invalid arithmetic sequence data'));\n            }\n            \n            const start = compressedData[1];\n            const diff = compressedData[2];\n            const lengthLow = compressedData[3];\n            const lengthHigh = compressedData[4];\n            const seqLength = lengthLow | (lengthHigh << 8);\n            \n            const seqResult = new Uint8Array(seqLength);\n            let currentValue = start;\n            \n            for (let i = 0; i < seqLength; i++) {\n              seqResult[i] = currentValue;\n              currentValue = (currentValue + diff) % 256;\n            }\n            \n            return resolve(seqResult);\n            \n          case 0xF2: // Modulo sequence\n            if (compressedData.length < 3) {\n              return reject(new Error('Invalid modulo sequence data'));\n            }\n            \n            const modLengthLow = compressedData[1];\n            const modLengthHigh = compressedData[2];\n            const modLength = modLengthLow | (modLengthHigh << 8);\n            \n            const modResult = new Uint8Array(modLength);\n            \n            for (let i = 0; i < modLength; i++) {\n              modResult[i] = i % 256;\n            }\n            \n            return resolve(modResult);\n            \n          case 0xF3: // High-entropy data\n            if (compressedData.length < 3) {\n              return reject(new Error('Invalid high-entropy data format'));\n            }\n            \n            const entLengthLow = compressedData[1];\n            const entLengthHigh = compressedData[2];\n            const entLength = entLengthLow | (entLengthHigh << 8);\n            \n            if (compressedData.length < 3 + entLength) {\n              return reject(new Error('Invalid high-entropy data length'));\n            }\n            \n            return resolve(compressedData.slice(3, 3 + entLength));\n            \n          case 0xF4: // Range-compressed data\n            if (compressedData.length < 4) {\n              return reject(new Error('Invalid range-compressed data format'));\n            }\n            \n            const minVal = compressedData[1];\n            // Max value used for bit calculation below\n            const bitsPerValue = compressedData[3];\n            \n            // Calculate how many values we can extract\n            const valuesPerByte = Math.floor(8 / bitsPerValue);\n            const totalBytes = compressedData.length - 4;\n            const totalValues = totalBytes * valuesPerByte;\n            \n            const rangeResult = new Uint8Array(totalValues);\n            let resultIndex = 0;\n            \n            // Bit mask for extracting values\n            const mask = (1 << bitsPerValue) - 1;\n            \n            // We're intentionally not using maxVal currently, but we might in future versions\n            // to handle more sophisticated range compression\n            \n            for (let i = 0; i < totalBytes && resultIndex < totalValues; i++) {\n              const currentByte = compressedData[i + 4];\n              \n              for (let j = 0; j < valuesPerByte && resultIndex < totalValues; j++) {\n                // Extract value and denormalize\n                const normalizedValue = (currentByte >> (j * bitsPerValue)) & mask;\n                rangeResult[resultIndex++] = minVal + normalizedValue;\n              }\n            }\n            \n            return resolve(rangeResult);\n            \n          case 0xF5: // Delta encoding\n            if (compressedData.length < 2) {\n              return reject(new Error('Invalid delta-encoded data format'));\n            }\n            \n            const firstByte = compressedData[1];\n            const deltaResult = new Uint8Array(compressedData.length - 1);\n            deltaResult[0] = firstByte;\n            \n            // Reconstruct from deltas\n            for (let i = 1; i < deltaResult.length; i++) {\n              const delta = compressedData[i + 1];\n              // Convert from unsigned byte to signed delta\n              const signedDelta = delta <= 127 ? delta : delta - 256;\n              deltaResult[i] = (deltaResult[i-1] + signedDelta) & 0xFF;\n            }\n            \n            return resolve(deltaResult);\n            \n          case 0xF6: // Dictionary compression\n            if (compressedData.length < 3) {\n              return reject(new Error('Invalid dictionary compressed data'));\n            }\n            \n            const dictSize = compressedData[1];\n            if (dictSize === 0 || compressedData.length < 2 + dictSize * 2) {\n              return reject(new Error('Invalid dictionary size'));\n            }\n            \n            // Read dictionary\n            const dictionary = [];\n            let offset = 2;\n            \n            for (let i = 0; i < dictSize; i++) {\n              dictionary.push([compressedData[offset], compressedData[offset + 1]]);\n              offset += 2;\n            }\n            \n            // Decompress data\n            const dictResult = [];\n            \n            while (offset < compressedData.length) {\n              if ((compressedData[offset] & 0xF0) === 0xE0) {\n                // Dictionary reference\n                const dictIndex = compressedData[offset] & 0x0F;\n                if (dictIndex < dictionary.length) {\n                  dictResult.push(dictionary[dictIndex][0], dictionary[dictIndex][1]);\n                } else {\n                  dictResult.push(compressedData[offset]);\n                }\n                offset++;\n              } else {\n                // Literal byte\n                dictResult.push(compressedData[offset]);\n                offset++;\n              }\n            }\n            \n            return resolve(new Uint8Array(dictResult));\n            \n          case 0xF7: // Uncompressed data\n            if (compressedData.length < 3) {\n              return reject(new Error('Invalid uncompressed data format'));\n            }\n            \n            const rawLengthLow = compressedData[1];\n            const rawLengthHigh = compressedData[2];\n            const rawLength = rawLengthLow | (rawLengthHigh << 8);\n            \n            if (compressedData.length < 3 + rawLength) {\n              return reject(new Error('Invalid uncompressed data length'));\n            }\n            \n            return resolve(compressedData.slice(3, 3 + rawLength));\n            \n          default:\n            // Unknown compression, or raw data - return as is\n            return resolve(compressedData);\n        }\n      } catch (error) {\n        console.error('Decompression error:', error);\n        const errorMessage = error instanceof Error \n          ? error.message \n          : String(error);\n        reject(new Error(`Decompression error: ${errorMessage || 'Unknown error'}`));\n      }\n    });\n  }\n  \n  /**\n   * Decompress block-based compression format\n   */\n  private async decompressBlocks(compressedData: Uint8Array): Promise<Uint8Array> {\n    // Check for minimum valid header size\n    if (compressedData.length < 7) {\n      throw new Error('Invalid block-compressed data format: Header too small');\n    }\n    \n    // Check marker byte\n    if (compressedData[0] !== 0xB1) {\n      throw new Error('Invalid block-compressed data format: Invalid marker byte');\n    }\n    \n    // Read header\n    const blockCountLow = compressedData[1];\n    const blockCountHigh = compressedData[2];\n    const blockCount = blockCountLow | (blockCountHigh << 8);\n    \n    // Read block size (now 4 bytes)\n    const blockSizeByte1 = compressedData[3];\n    const blockSizeByte2 = compressedData[4]; \n    const blockSizeByte3 = compressedData[5];\n    const blockSizeByte4 = compressedData[6];\n    \n    // Combine into a 32-bit block size\n    const blockSize = blockSizeByte1 | \n                     (blockSizeByte2 << 8) | \n                     (blockSizeByte3 << 16) | \n                     (blockSizeByte4 << 24);\n    \n    console.debug(`Decompressing ${blockCount} blocks with nominal block size of ${blockSize} bytes`);\n    \n    // Sanity check for block count to prevent OOM errors\n    if (blockCount > 10000) {\n      throw new Error(`Invalid block count: ${blockCount} (maximum 10000)`);\n    }\n    \n    // An array to hold all decompressed blocks\n    const decompressedBlocks: Uint8Array[] = [];\n    let offset = 7; // Start after 7-byte header\n    \n    // Decompress each block\n    for (let i = 0; i < blockCount; i++) {\n      // Check if we have enough data for block header (5 bytes)\n      if (offset + 5 > compressedData.length) {\n        throw new Error(`Invalid block header at block ${i}: Not enough data remaining`);\n      }\n      \n      // Read block header - now 5 bytes (1 for strategy, 4 for size)\n      const strategyId = compressedData[offset];\n      \n      // Read 4-byte block length\n      const blockLengthByte1 = compressedData[offset + 1];\n      const blockLengthByte2 = compressedData[offset + 2];\n      const blockLengthByte3 = compressedData[offset + 3];\n      const blockLengthByte4 = compressedData[offset + 4];\n      \n      // Combine into a 32-bit block length\n      const blockLength = blockLengthByte1 | \n                         (blockLengthByte2 << 8) | \n                         (blockLengthByte3 << 16) | \n                         (blockLengthByte4 << 24);\n      \n      // Move past the header\n      offset += 5;\n      \n      // Sanity check for block length\n      if (blockLength > 10 * 1024 * 1024) { // Max 10MB per block as sanity check\n        throw new Error(`Invalid block length at block ${i}: ${blockLength} bytes (maximum 10MB)`);\n      }\n      \n      // Check if we have enough data for the block\n      if (offset + blockLength > compressedData.length) {\n        throw new Error(`Invalid block data at block ${i}: Expected ${blockLength} bytes but only ${compressedData.length - offset} remaining`);\n      }\n      \n      // Extract block data\n      const blockData = compressedData.slice(offset, offset + blockLength);\n      offset += blockLength;\n      \n      // Log progress for large files\n      if (blockCount > 20 && (i === 0 || i === blockCount - 1 || i % 10 === 0)) {\n        console.debug(`Decompressing block ${i+1}/${blockCount}`);\n      }\n      \n      try {\n        // Get strategy name from ID\n        const strategy = this.getStrategyFromId(strategyId);\n        \n        // Handle raw blocks directly\n        if (strategy === 'raw' || strategyId === 0xFF) {\n          // Raw blocks are already marked with 0xF7 internally\n          const decompressedBlock = await this.realDecompress(blockData);\n          decompressedBlocks.push(decompressedBlock);\n          continue;\n        }\n        \n        // For compressed blocks, add the appropriate marker if needed\n        // Check if block already has a valid marker\n        if (blockData.length > 0 && this.isValidMarker(blockData[0])) {\n          // Block already has a marker, use as is\n          const decompressedBlock = await this.realDecompress(blockData);\n          decompressedBlocks.push(decompressedBlock);\n        } else {\n          // Add a marker based on the strategy\n          const markerByte = this.getMarkerForStrategy(strategy, blockData);\n          \n          // Create a new array with the marker + the block data\n          const markedBlockData = new Uint8Array(blockData.length + 1);\n          markedBlockData[0] = markerByte;\n          markedBlockData.set(blockData, 1);\n          \n          // Decompress this block\n          const decompressedBlock = await this.realDecompress(markedBlockData);\n          decompressedBlocks.push(decompressedBlock);\n        }\n      } catch (error) {\n        console.error(`Error decompressing block ${i}:`, error);\n        throw new Error(`Failed to decompress block ${i}: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    }\n    \n    // Calculate total decompressed size\n    let totalSize = 0;\n    for (const block of decompressedBlocks) {\n      totalSize += block.length;\n    }\n    \n    // Combine all blocks\n    const result = new Uint8Array(totalSize);\n    let outputOffset = 0;\n    \n    for (const block of decompressedBlocks) {\n      result.set(block, outputOffset);\n      outputOffset += block.length;\n    }\n    \n    console.debug(`Block decompression complete: ${compressedData.length}  ${result.length} bytes`);\n    return result;\n  }\n  \n  /**\n   * Check if a byte is a valid compression marker\n   */\n  private isValidMarker(byte: number): boolean {\n    const validMarkers = [0xC0, 0xC1, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xB1];\n    return validMarkers.includes(byte);\n  }\n  \n  /**\n   * Get strategy name from ID for block headers\n   */\n  private getStrategyFromId(id: number): string {\n    switch (id) {\n      case 1: return 'pattern';\n      case 2: return 'sequential';\n      case 3: return 'spectral';\n      case 4: return 'dictionary';\n      case 5: return 'raw'; // Uncompressed data\n      case 0xFF: return 'raw'; // Alternative code for raw\n      default: return 'auto';\n    }\n  }\n  \n  /**\n   * Get the appropriate marker byte for a compression strategy\n   * when decompressing blocks\n   */\n  private getMarkerForStrategy(strategy: string, data: Uint8Array): number {\n    // Detect the marker based on data patterns if not available directly\n    switch (strategy) {\n      case 'pattern':\n        return data.length > 0 && data[0] === 0xFF ? 0xF0 : 0xC0;\n      case 'sequential':\n        return 0xF1;\n      case 'spectral':\n        return 0xF5; // Default to delta encoding\n      case 'dictionary':\n        return 0xF6;\n      default:\n        return 0xF7; // Default to uncompressed\n    }\n  }\n\n  /**\n   * Get available compression strategies\n   */\n  private realGetAvailableStrategies(): Promise<{ id: string, name: string }[]> {\n    return Promise.resolve([\n      { id: 'auto', name: 'Auto (Best)' },\n      { id: 'pattern', name: 'Pattern Recognition' },\n      { id: 'sequential', name: 'Sequential' },\n      { id: 'spectral', name: 'Spectral' },\n      { id: 'dictionary', name: 'Dictionary' }\n    ]);\n  }\n}\n\n// Export the singleton instance\nexport default PrimeCompressWasm.getInstance();"],"names":["WasmStatus","PrimeCompressWasm","constructor","status","NOT_LOADED","error","wasmModule","loadPromise","getInstance","instance","getStatus","this","getError","load","LOADED","Promise","resolve","LOADING","reject","console","log","strategies","pattern","patternCompress","bind","sequential","sequentialCompress","spectral","spectralCompress","dictionary","dictionaryCompress","auto","autoCompress","compress","realCompress","decompress","realDecompress","getAvailableStrategies","realGetAvailableStrategies","err","ERROR","Error","String","data","options","arguments","length","undefined","compressedData","calculateChecksum","hash","i","toString","padStart","calculateEntropy","counts","Array","fill","entropy","p","Math","log2","strategy","entropyScore","stats","analyzeBlock","scores","isConstant","hasPattern","hasSequence","isTextLike","hasSpectralPattern","bestStrategy","bestScore","debug","toFixed","firstByte","detectPattern","detectSequence","detectSpectralPattern","sampleInterval","ceil","allSame","sampleSize","min","runThreshold","max","floor","currentByte","runLength","maxRunLength","totalRunLength","runCheckLimit","runRatio","patternCheckLimit","patternLength","isPattern","matchCount","minMatches","checkSize","samplingRate","diffs","push","firstDiff","filter","diff","every","firstDerivative","signChanges","lastSign","currentDiff","currentSign","textChars","wordChars","spaces","Uint8Array","result","patternFound","from","slice","litLength","maxLitLength","nextByte","nextRunLength","j","isModulo","set","bitsRequired","bitsFilled","normalizedValue","delta","MAX_DICT_SCAN","dictScanSize","sampledData","headSize","samplePos","tailStart","remainingSpace","freqTable","pairs","Map","pairHash","get","maxPairs","sortedPairs","entries","sort","a","b","map","entry","sampleCompressed","sampleLimit","dictIndex","indexOf","dictionarySize","estimatedRatio","compressed","byte1","byte2","startTime","performance","now","strategyToUse","autoSelectedStrategy","useBlocks","compressWithBlocks","compressionRatio","compressionTime","originalSize","compressedSize","errorMessage","message","defaultStrategy","blockSize","numBlocks","blocks","blockStrategies","blockSizes","header","strategyUsage","blockStart","blockEnd","block","shouldAnalyze","compressedBlock","blockStrategy","blockHeader","strategyId","getStrategyId","totalSize","offset","marker","decompressBlocks","then","catch","value","constantResult","repeatCount","patternResult","count","start","lengthLow","seqLength","seqResult","currentValue","modLengthLow","modLength","modResult","entLengthLow","entLength","minVal","bitsPerValue","valuesPerByte","totalBytes","totalValues","rangeResult","resultIndex","mask","deltaResult","signedDelta","dictSize","dictResult","rawLengthLow","rawLength","blockCount","decompressedBlocks","blockLength","blockData","getStrategyFromId","decompressedBlock","isValidMarker","markerByte","getMarkerForStrategy","markedBlockData","outputOffset","byte","includes","id","name"],"sourceRoot":""}