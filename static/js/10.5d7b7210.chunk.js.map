{"version":3,"file":"static/js/10.5d7b7210.chunk.js","mappings":"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","sources":["wasm/prime-compress-wasm.ts"],"sourcesContent":["/**\n * WebAssembly bindings for PrimeCompress\n * \n * This module provides a bridge between the PrimeCompress library and the browser\n * environment using WebAssembly.\n * \n * This implementation incorporates compression algorithms from unified-compression.js\n * into a JavaScript-based implementation that mimics a WebAssembly module.\n */\n\n/**\n * Interface for compression options\n */\nexport interface CompressionOptions {\n  strategy?: string;\n  useBlocks?: boolean;\n  fastPathForRandom?: boolean;\n}\n\n/**\n * WebAssembly module status\n */\nexport enum WasmStatus {\n  NOT_LOADED = 'not_loaded',\n  LOADING = 'loading',\n  LOADED = 'loaded',\n  ERROR = 'error'\n}\n\n/**\n * Singleton class to manage the WebAssembly module\n */\nclass PrimeCompressWasm {\n  private static instance: PrimeCompressWasm;\n  private status: WasmStatus = WasmStatus.NOT_LOADED;\n  private error: Error | null = null;\n  private wasmModule: any = null;\n  private loadPromise: Promise<void> | null = null;\n\n  private constructor() {\n    // Private constructor to enforce singleton pattern\n  }\n\n  /**\n   * Get the singleton instance\n   */\n  public static getInstance(): PrimeCompressWasm {\n    if (!PrimeCompressWasm.instance) {\n      PrimeCompressWasm.instance = new PrimeCompressWasm();\n    }\n    return PrimeCompressWasm.instance;\n  }\n\n  /**\n   * Get the current status of the WASM module\n   */\n  public getStatus(): WasmStatus {\n    return this.status;\n  }\n\n  /**\n   * Get any error that occurred during loading\n   */\n  public getError(): Error | null {\n    return this.error;\n  }\n\n  /**\n   * Load the WebAssembly module\n   */\n  public async load(): Promise<void> {\n    // If already loading, return the existing promise\n    if (this.loadPromise) {\n      return this.loadPromise;\n    }\n\n    // If already loaded, return immediately\n    if (this.status === WasmStatus.LOADED) {\n      return Promise.resolve();\n    }\n\n    this.status = WasmStatus.LOADING;\n    \n    this.loadPromise = new Promise<void>((resolve, reject) => {\n      console.log('Loading PrimeCompress WebAssembly module...');\n      try {\n        // Create JavaScript functions based on the algorithms from unified-compression.js\n        const strategies = {\n          pattern: this.patternCompress.bind(this),\n          sequential: this.sequentialCompress.bind(this), \n          spectral: this.spectralCompress.bind(this),\n          dictionary: this.dictionaryCompress.bind(this),\n          auto: this.autoCompress.bind(this)\n        };\n        \n        // Create module interface\n        this.wasmModule = {\n          compress: this.realCompress.bind(this, strategies),\n          decompress: this.realDecompress.bind(this),\n          getAvailableStrategies: this.realGetAvailableStrategies.bind(this)\n        };\n        \n        console.log('PrimeCompress module loaded successfully');\n        this.status = WasmStatus.LOADED;\n        resolve();\n      } catch (err) {\n        console.error('Failed to load WebAssembly module:', err);\n        this.status = WasmStatus.ERROR;\n        this.error = err instanceof Error ? err : new Error(String(err));\n        reject(this.error);\n      }\n    });\n    \n    return this.loadPromise;\n  }\n\n  /**\n   * Compress data using the WebAssembly module\n   */\n  public async compress(\n    data: Uint8Array, \n    options: CompressionOptions = {}\n  ): Promise<{ \n    compressedData: Uint8Array, \n    compressionRatio: number, \n    strategy: string,\n    originalSize: number,\n    compressedSize: number,\n    compressionTime: number\n  }> {\n    if (this.status !== WasmStatus.LOADED) {\n      await this.load();\n    }\n    \n    // Call the actual WebAssembly module's compress function\n    return this.wasmModule.compress(data, options);\n  }\n\n  /**\n   * Decompress data using the WebAssembly module\n   */\n  public async decompress(compressedData: Uint8Array): Promise<Uint8Array> {\n    if (this.status !== WasmStatus.LOADED) {\n      await this.load();\n    }\n    \n    // Call the actual WebAssembly module's decompress function\n    return this.wasmModule.decompress(compressedData);\n  }\n\n  /**\n   * Get available compression strategies\n   */\n  public async getAvailableStrategies(): Promise<{ id: string, name: string }[]> {\n    if (this.status !== WasmStatus.LOADED) {\n      await this.load();\n    }\n    \n    // Call the actual WebAssembly module's getAvailableStrategies function\n    return this.wasmModule.getAvailableStrategies();\n  }\n\n  /**\n   * Calculate checksum for data integrity\n   */\n  private calculateChecksum(data: Uint8Array): string {\n    let hash = 0;\n    \n    for (let i = 0; i < data.length; i++) {\n      const byte = data[i];\n      hash = ((hash << 5) - hash) + byte;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    \n    // Convert to hex string\n    return (hash >>> 0).toString(16).padStart(8, '0');\n  }\n\n  /**\n   * Calculate entropy of the data\n   */\n  private calculateEntropy(data: Uint8Array): number {\n    const counts = new Array(256).fill(0);\n    \n    // Count frequency of each byte value\n    for (let i = 0; i < data.length; i++) {\n      counts[data[i]]++;\n    }\n    \n    // Calculate entropy\n    let entropy = 0;\n    for (let i = 0; i < 256; i++) {\n      if (counts[i] > 0) {\n        const p = counts[i] / data.length;\n        entropy -= p * Math.log2(p);\n      }\n    }\n    \n    return entropy;\n  }\n\n  /**\n   * Auto-select compression strategy based on data characteristics\n   */\n  private autoCompress(data: Uint8Array): { strategy: string, entropyScore: number } {\n    // Main logic ported from unified-compression.js's StrategyScorer\n    \n    // Calculate entropy\n    const entropy = this.calculateEntropy(data);\n    \n    // Basic analysis\n    const stats = this.analyzeBlock(data);\n    \n    // Decision logic\n    if (stats.isConstant) return { strategy: 'pattern', entropyScore: entropy };\n    if (stats.hasPattern) return { strategy: 'pattern', entropyScore: entropy };\n    if (stats.hasSequence) return { strategy: 'sequential', entropyScore: entropy };\n    if (stats.isTextLike) return { strategy: 'dictionary', entropyScore: entropy };\n    if (entropy > 7.0) return { strategy: 'spectral', entropyScore: entropy }; // High entropy data\n    \n    // Default to dictionary for general data\n    return { strategy: 'dictionary', entropyScore: entropy };\n  }\n\n  /**\n   * Analyze data block for compression strategy selection\n   */\n  private analyzeBlock(data: Uint8Array): {\n    entropy: number,\n    isConstant: boolean,\n    hasPattern: boolean,\n    hasSequence: boolean,\n    hasSpectralPattern: boolean,\n    isTextLike: boolean\n  } {\n    const stats = {\n      entropy: this.calculateEntropy(data),\n      isConstant: true,\n      hasPattern: false,\n      hasSequence: false,\n      hasSpectralPattern: false,\n      isTextLike: false,\n    };\n    \n    // Check if all bytes are the same (constant)\n    if (data.length > 0) {\n      const firstByte = data[0];\n      for (let i = 1; i < data.length; i++) {\n        if (data[i] !== firstByte) {\n          stats.isConstant = false;\n          break;\n        }\n      }\n    }\n    \n    // Check for repeating patterns\n    if (!stats.isConstant && data.length >= 8) {\n      stats.hasPattern = this.detectPattern(data);\n    }\n    \n    // Check for sequential patterns\n    if (!stats.isConstant && !stats.hasPattern && data.length >= 8) {\n      stats.hasSequence = this.detectSequence(data);\n    }\n    \n    // Check for spectral patterns (sine waves, etc.)\n    if (!stats.isConstant && data.length >= 16) {\n      stats.hasSpectralPattern = this.detectSpectralPattern(data);\n    }\n    \n    // Check if data appears to be text\n    if (data.length > 0) {\n      stats.isTextLike = this.isTextLike(data);\n    }\n    \n    return stats;\n  }\n\n  /**\n   * Detect repeating patterns in data\n   */\n  private detectPattern(data: Uint8Array): boolean {\n    // Basic pattern detection algorithm\n    if (data.length < 8) return false;\n    \n    // Check if all bytes are the same\n    const firstByte = data[0];\n    let allSame = true;\n    for (let i = 1; i < Math.min(64, data.length); i++) {\n      if (data[i] !== firstByte) {\n        allSame = false;\n        break;\n      }\n    }\n    if (allSame) return true;\n    \n    // Check for repeating patterns (up to 8 bytes)\n    for (let patternLength = 2; patternLength <= 8; patternLength++) {\n      let isPattern = true;\n      for (let i = patternLength; i < Math.min(patternLength * 8, data.length); i++) {\n        if (data[i] !== data[i % patternLength]) {\n          isPattern = false;\n          break;\n        }\n      }\n      if (isPattern) return true;\n    }\n    \n    // Check for long runs of the same byte\n    let currentByte = data[0];\n    let runLength = 1;\n    let maxRunLength = 1;\n    \n    for (let i = 1; i < data.length; i++) {\n      if (data[i] === currentByte) {\n        runLength++;\n      } else {\n        currentByte = data[i];\n        runLength = 1;\n      }\n      \n      if (runLength > maxRunLength) {\n        maxRunLength = runLength;\n      }\n    }\n    \n    // If we have runs of 8+ bytes, consider it a pattern\n    if (maxRunLength >= 8) return true;\n    \n    return false;\n  }\n\n  /**\n   * Detect sequential patterns in data\n   */\n  private detectSequence(data: Uint8Array): boolean {\n    if (data.length < 8) return false;\n    \n    // Check for arithmetic sequence (constant difference)\n    const diffs = [];\n    for (let i = 1; i < Math.min(16, data.length); i++) {\n      diffs.push((data[i] - data[i-1] + 256) % 256); // Handle wrap around\n    }\n    \n    const firstDiff = diffs[0];\n    const isArithmetic = diffs.every(diff => diff === firstDiff);\n    \n    return isArithmetic;\n  }\n\n  /**\n   * Detect spectral patterns in data\n   */\n  private detectSpectralPattern(data: Uint8Array): boolean {\n    // Simplified spectral analysis\n    // Check for oscillating patterns in the data\n    if (data.length < 16) return false;\n    \n    // Look for sinusoidal-like patterns\n    // Compute first and second derivatives\n    const firstDerivative = [];\n    for (let i = 1; i < data.length; i++) {\n      firstDerivative.push((data[i] - data[i-1] + 256) % 256);\n    }\n    \n    // Check for sign changes in the first derivative\n    // which would indicate peaks and valleys\n    let signChanges = 0;\n    let lastSign = firstDerivative[0] > 0 ? 1 : (firstDerivative[0] < 0 ? -1 : 0);\n    \n    for (let i = 1; i < firstDerivative.length; i++) {\n      const currentDiff = firstDerivative[i];\n      const currentSign = currentDiff > 0 ? 1 : (currentDiff < 0 ? -1 : 0);\n      \n      if (currentSign !== 0 && lastSign !== 0 && currentSign !== lastSign) {\n        signChanges++;\n      }\n      \n      if (currentSign !== 0) {\n        lastSign = currentSign;\n      }\n    }\n    \n    // If we have several sign changes, it might be a sinusoidal pattern\n    return signChanges >= 4;\n  }\n\n  /**\n   * Check if data is likely text\n   */\n  private isTextLike(data: Uint8Array): boolean {\n    if (data.length === 0) return false;\n    \n    let textChars = 0;\n    let wordChars = 0;\n    let spaces = 0;\n    const sampleSize = Math.min(data.length, 100);\n    \n    for (let i = 0; i < sampleSize; i++) {\n      // Check for ASCII text range (printable characters)\n      if (data[i] >= 32 && data[i] <= 126) {\n        textChars++;\n        \n        // Count word characters (a-z, A-Z) and spaces\n        if ((data[i] >= 65 && data[i] <= 90) || (data[i] >= 97 && data[i] <= 122)) {\n          wordChars++;\n        } else if (data[i] === 32) {\n          spaces++;\n        }\n      }\n    }\n    \n    // More sophisticated text detection - high proportion of letters and spaces\n    const textRatio = textChars / sampleSize;\n    const wordRatio = (wordChars + spaces) / sampleSize;\n    \n    return textRatio > 0.7 && wordRatio > 0.4;\n  }\n  \n  /**\n   * Pattern-based compression strategy (improved RLE)\n   */\n  private patternCompress(data: Uint8Array): Uint8Array {\n    if (data.length === 0) return new Uint8Array(0);\n    \n    // Check if all bytes are the same\n    let isConstant = true;\n    const firstByte = data[0];\n    \n    for (let i = 1; i < data.length; i++) {\n      if (data[i] !== firstByte) {\n        isConstant = false;\n        break;\n      }\n    }\n    \n    // Special case: constant data (all bytes are the same)\n    if (isConstant) {\n      const result = new Uint8Array(3);\n      result[0] = 0xC0; // Marker for constant data\n      result[1] = firstByte; // The constant value\n      result[2] = Math.min(255, data.length); // Length (up to 255)\n      return result;\n    }\n    \n    // Check for repeating pattern\n    let patternFound = false;\n    let pattern: number[] = [];\n    \n    // Try to find a repeating pattern (up to 16 bytes)\n    for (let patternLength = 2; patternLength <= 16; patternLength++) {\n      if (data.length < patternLength * 2) continue;\n      \n      let isPattern = true;\n      pattern = Array.from(data.slice(0, patternLength));\n      \n      for (let i = patternLength; i < data.length; i++) {\n        if (data[i] !== pattern[i % patternLength]) {\n          isPattern = false;\n          break;\n        }\n      }\n      \n      if (isPattern) {\n        patternFound = true;\n        break;\n      }\n    }\n    \n    // If we found a repeating pattern, encode efficiently\n    if (patternFound && pattern.length > 0 && pattern.length <= 16) {\n      const result = new Uint8Array(3 + pattern.length);\n      result[0] = 0xC1; // Marker for repeating pattern\n      result[1] = pattern.length; // Pattern length\n      result[2] = Math.floor(data.length / pattern.length); // Repeat count\n      \n      // Store the pattern\n      for (let i = 0; i < pattern.length; i++) {\n        result[3 + i] = pattern[i];\n      }\n      \n      return result;\n    }\n    \n    // General RLE compression\n    const result = [];\n    let i = 0;\n    \n    // Header byte indicating RLE compression\n    result.push(0xF0); // Marker for RLE compression\n    \n    while (i < data.length) {\n      // Look for runs of the same byte\n      let runLength = 1;\n      const currentByte = data[i];\n      \n      while (i + runLength < data.length && data[i + runLength] === currentByte && runLength < 255) {\n        runLength++;\n      }\n      \n      if (runLength >= 4) {\n        // Encode as a run\n        result.push(0xFF); // Run marker\n        result.push(runLength); // Run length\n        result.push(currentByte); // Byte value\n        i += runLength;\n      } else {\n        // Check for a short literal run\n        let litLength = 1;\n        let maxLitLength = Math.min(127, data.length - i);\n        \n        while (litLength < maxLitLength) {\n          // Look ahead to see if we'd benefit from a run\n          const nextByte = data[i + litLength];\n          let nextRunLength = 1;\n          \n          while (i + litLength + nextRunLength < data.length && \n                data[i + litLength + nextRunLength] === nextByte && \n                nextRunLength < 255) {\n            nextRunLength++;\n          }\n          \n          // If we have a good run coming up, stop the literal sequence\n          if (nextRunLength >= 4) break;\n          \n          litLength++;\n        }\n        \n        // Encode the literal sequence\n        result.push(litLength - 1); // Literal length (0-127 means 1-128 bytes)\n        for (let j = 0; j < litLength; j++) {\n          result.push(data[i + j]);\n        }\n        \n        i += litLength;\n      }\n    }\n    \n    return new Uint8Array(result);\n  }\n  \n  /**\n   * Sequential compression strategy\n   */\n  private sequentialCompress(data: Uint8Array): Uint8Array {\n    if (data.length < 4) return data; // Too small to compress\n    \n    // Check if data follows a simple arithmetic sequence\n    const diffs = [];\n    for (let i = 1; i < Math.min(16, data.length); i++) {\n      diffs.push((data[i] - data[i-1] + 256) % 256); // Handle wrap around\n    }\n    \n    const firstDiff = diffs[0];\n    const isArithmetic = diffs.every(diff => diff === firstDiff);\n    \n    if (isArithmetic) {\n      // Arithmetic sequence: store [marker, start, difference, length (2 bytes)]\n      const result = new Uint8Array(5);\n      result[0] = 0xF1; // Marker for arithmetic sequence\n      result[1] = data[0]; // Start value\n      result[2] = firstDiff; // Common difference\n      result[3] = data.length & 0xFF; // Length (low byte)\n      result[4] = (data.length >> 8) & 0xFF; // Length (high byte)\n      return result;\n    }\n    \n    // Check for modulo pattern (i % 256, commonly used in test data)\n    let isModulo = true;\n    for (let i = 0; i < Math.min(256, data.length); i++) {\n      if (data[i] !== (i % 256)) {\n        isModulo = false;\n        break;\n      }\n    }\n    \n    if (isModulo) {\n      // Modulo sequence: store [marker, length (2 bytes)]\n      const result = new Uint8Array(3);\n      result[0] = 0xF2; // Marker for modulo sequence\n      result[1] = data.length & 0xFF; // Length (low byte)\n      result[2] = (data.length >> 8) & 0xFF; // Length (high byte)\n      return result;\n    }\n    \n    // If not a simple sequence, fall back to patterns or dictionary\n    return this.patternCompress(data);\n  }\n  \n  /**\n   * Spectral compression for high-entropy data\n   */\n  private spectralCompress(data: Uint8Array): Uint8Array {\n    // For high-entropy random data, just store with minimal overhead\n    if (this.calculateEntropy(data) > 7.0) {\n      const result = new Uint8Array(data.length + 3);\n      result[0] = 0xF3; // Marker for high-entropy data\n      result[1] = data.length & 0xFF; // Length (low byte)\n      result[2] = (data.length >> 8) & 0xFF; // Length (high byte)\n      result.set(data, 3);\n      return result;\n    }\n    \n    // For spectrally compressible data (oscillating patterns)\n    // Attempt basic Fourier-inspired encoding\n    \n    // Find min and max values for normalization\n    let min = 255;\n    let max = 0;\n    \n    for (let i = 0; i < data.length; i++) {\n      if (data[i] < min) min = data[i];\n      if (data[i] > max) max = data[i];\n    }\n    \n    // If the range is small, use a simplified encoding\n    if (max - min <= 32) {\n      const result = [];\n      result.push(0xF4); // Marker for range-compressed data\n      result.push(min); // Minimum value\n      result.push(max); // Maximum value\n      \n      // Pack multiple values into each byte when possible\n      const bitsRequired = Math.ceil(Math.log2(max - min + 1));\n      const valuesPerByte = Math.floor(8 / bitsRequired);\n      \n      if (valuesPerByte >= 2) {\n        result.push(bitsRequired); // Bits per value\n        \n        let currentByte = 0;\n        let bitsFilled = 0;\n        \n        for (let i = 0; i < data.length; i++) {\n          // Normalize to 0-(max-min) range\n          const normalizedValue = data[i] - min;\n          \n          // Pack into current byte\n          currentByte |= (normalizedValue << bitsFilled);\n          bitsFilled += bitsRequired;\n          \n          // If byte is full, store it and start a new one\n          if (bitsFilled >= 8) {\n            result.push(currentByte & 0xFF);\n            currentByte = normalizedValue >> (bitsRequired - (bitsFilled - 8));\n            bitsFilled = bitsFilled - 8;\n          }\n        }\n        \n        // Store any remaining bits\n        if (bitsFilled > 0) {\n          result.push(currentByte & 0xFF);\n        }\n        \n        return new Uint8Array(result);\n      }\n    }\n    \n    // Fall back to delta encoding for other data\n    const result = [];\n    result.push(0xF5); // Marker for delta encoding\n    result.push(data[0]); // Store first byte directly\n    \n    // Store deltas between consecutive bytes\n    for (let i = 1; i < data.length; i++) {\n      // Calculate delta (-128 to 127 range)\n      let delta = data[i] - data[i-1];\n      if (delta < -128) delta += 256;\n      if (delta > 127) delta -= 256;\n      \n      // Convert to unsigned byte representation\n      result.push(delta & 0xFF);\n    }\n    \n    return new Uint8Array(result);\n  }\n  \n  /**\n   * Dictionary-based compression with Huffman coding\n   */\n  private dictionaryCompress(data: Uint8Array): Uint8Array {\n    if (data.length < 8) return data; // Too small to compress\n    \n    // Build frequency table for Huffman coding\n    const freqTable = new Array(256).fill(0);\n    for (let i = 0; i < data.length; i++) {\n      freqTable[data[i]]++;\n    }\n    \n    // First pass: find frequent byte pairs for the dictionary\n    const pairs = new Map<number, number>(); // Maps pair hash to frequency\n    \n    for (let i = 0; i < data.length - 1; i++) {\n      const pairHash = (data[i] << 8) | data[i + 1];\n      pairs.set(pairHash, (pairs.get(pairHash) || 0) + 1);\n    }\n    \n    // Find most frequent pairs (up to 16)\n    const pairsArray = Array.from(pairs.entries());\n    const sortedPairs = pairsArray\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, 16)\n      .map(entry => entry[0]);\n    \n    if (sortedPairs.length === 0) {\n      // No repeating pairs - try simpler RLE compression\n      return this.patternCompress(data);\n    }\n    \n    // Create dictionary\n    const dictionary = sortedPairs.map(pairHash => {\n      return [pairHash >> 8, pairHash & 0xFF];\n    });\n    \n    // Compress data using the dictionary\n    const compressed = [];\n    compressed.push(0xF6); // Marker for dictionary compression\n    compressed.push(dictionary.length); // Dictionary size\n    \n    // Store dictionary\n    for (const [byte1, byte2] of dictionary) {\n      compressed.push(byte1);\n      compressed.push(byte2);\n    }\n    \n    // Compress data\n    let i = 0;\n    while (i < data.length) {\n      if (i < data.length - 1) {\n        const pairHash = (data[i] << 8) | data[i + 1];\n        const dictIndex = sortedPairs.indexOf(pairHash);\n        \n        if (dictIndex >= 0) {\n          // Dictionary reference\n          compressed.push(0xE0 | dictIndex); // Use 0xE0-0xEF for dictionary refs\n          i += 2; // Skip the pair\n          continue;\n        }\n      }\n      \n      // Literal byte\n      compressed.push(data[i]);\n      i++;\n    }\n    \n    // If our compression isn't effective, fall back to the original data\n    if (compressed.length >= data.length) {\n      // Just store the original data with a minimal header\n      const result = new Uint8Array(data.length + 3);\n      result[0] = 0xF7; // Marker for uncompressed data\n      result[1] = data.length & 0xFF; // Length (low byte)\n      result[2] = (data.length >> 8) & 0xFF; // Length (high byte)\n      result.set(data, 3);\n      return result;\n    }\n    \n    return new Uint8Array(compressed);\n  }\n  \n  /**\n   * Real compression function with strategy selection and block-based processing\n   */\n  private realCompress(\n    strategies: any,\n    data: Uint8Array, \n    options: CompressionOptions = {}\n  ): Promise<{ \n    compressedData: Uint8Array, \n    compressionRatio: number, \n    strategy: string,\n    originalSize: number,\n    compressedSize: number,\n    compressionTime: number\n  }> {\n    return new Promise((resolve) => {\n      // Start timer\n      const startTime = performance.now();\n      \n      try {\n        // Determine compression strategy to use\n        let strategyToUse = options.strategy || 'auto';\n        let autoSelectedStrategy = '';\n        \n        if (strategyToUse === 'auto') {\n          // Auto-select the best strategy for the data\n          const autoResult = this.autoCompress(data);\n          autoSelectedStrategy = autoResult.strategy;\n          strategyToUse = autoSelectedStrategy;\n        }\n        \n        // Determine if we should use block-based compression\n        const useBlocks = options.useBlocks !== false && data.length > 8192; // Default to block compression for data > 8KB\n        \n        // Apply the selected compression strategy\n        let compressedData: Uint8Array;\n        \n        if (useBlocks) {\n          // Block-based compression for large files\n          compressedData = this.compressWithBlocks(data, strategyToUse, strategies);\n        } else {\n          // Regular compression for smaller files\n          switch (strategyToUse) {\n            case 'pattern':\n              compressedData = strategies.pattern(data);\n              break;\n            case 'sequential':\n              compressedData = strategies.sequential(data);\n              break;\n            case 'spectral':\n              compressedData = strategies.spectral(data);\n              break;\n            case 'dictionary':\n              compressedData = strategies.dictionary(data);\n              break;\n            default:\n              // Fall back to auto-selection\n              const bestStrategy = strategies.auto(data).strategy;\n              switch (bestStrategy) {\n                case 'pattern':\n                  compressedData = strategies.pattern(data);\n                  break;\n                case 'sequential':\n                  compressedData = strategies.sequential(data);\n                  break;\n                case 'spectral':\n                  compressedData = strategies.spectral(data);\n                  break;\n                case 'dictionary':\n                  compressedData = strategies.dictionary(data);\n                  break;\n                default:\n                  compressedData = strategies.dictionary(data);\n                  strategyToUse = 'dictionary';\n              }\n          }\n        }\n        \n        // Calculate compression ratio and time\n        const compressionRatio = data.length / compressedData.length;\n        const compressionTime = performance.now() - startTime;\n        \n        // Prepare result object\n        resolve({\n          compressedData,\n          compressionRatio,\n          strategy: strategyToUse,\n          originalSize: data.length,\n          compressedSize: compressedData.length,\n          compressionTime\n        });\n      } catch (error) {\n        console.error('Compression error:', error);\n        \n        // In case of error, throw it instead of returning uncompressed data\n        const errorMessage = error instanceof Error \n          ? error.message \n          : String(error);\n        throw new Error(`Compression failed: ${errorMessage || 'Unknown error'}`);\n      }\n    });\n  }\n  \n  /**\n   * Block-based compression for large data\n   * Splits data into blocks and compresses each with potentially different strategies\n   */\n  private compressWithBlocks(\n    data: Uint8Array, \n    defaultStrategy: string,\n    strategies: any\n  ): Uint8Array {\n    // Size for each block - adaptive based on total size\n    const blockSize = data.length > 1024 * 1024 ? 65536 : 16384; // 64KB blocks for >1MB data, 16KB otherwise\n    \n    const numBlocks = Math.ceil(data.length / blockSize);\n    const blocks: Uint8Array[] = [];\n    const blockStrategies: string[] = [];\n    const blockSizes: number[] = [];\n    \n    // Initial blocks array will contain a header\n    // Format: [0xB1, block count (2 bytes), block size (2 bytes)]\n    const header = new Uint8Array(5);\n    header[0] = 0xB1; // Block marker\n    header[1] = numBlocks & 0xFF; // Block count low byte\n    header[2] = (numBlocks >> 8) & 0xFF; // Block count high byte\n    header[3] = blockSize & 0xFF; // Block size low byte\n    header[4] = (blockSize >> 8) & 0xFF; // Block size high byte\n    blocks.push(header);\n    \n    // Process each block\n    for (let i = 0; i < numBlocks; i++) {\n      const blockStart = i * blockSize;\n      const blockEnd = Math.min(blockStart + blockSize, data.length);\n      const block = data.slice(blockStart, blockEnd);\n      \n      // Analyze this block for optimal strategy\n      let blockStrategy = defaultStrategy;\n      if (defaultStrategy === 'auto') {\n        blockStrategy = this.autoCompress(block).strategy;\n      }\n      \n      // Compress block\n      let compressedBlock: Uint8Array;\n      switch (blockStrategy) {\n        case 'pattern':\n          compressedBlock = strategies.pattern(block);\n          break;\n        case 'sequential':\n          compressedBlock = strategies.sequential(block);\n          break;\n        case 'spectral':\n          compressedBlock = strategies.spectral(block);\n          break;\n        case 'dictionary':\n          compressedBlock = strategies.dictionary(block);\n          break;\n        default:\n          compressedBlock = strategies.dictionary(block);\n          blockStrategy = 'dictionary';\n      }\n      \n      // Create block header [strategy id (1 byte), size (2 bytes)]\n      const blockHeader = new Uint8Array(3);\n      const strategyId = this.getStrategyId(blockStrategy);\n      blockHeader[0] = strategyId;\n      blockHeader[1] = compressedBlock.length & 0xFF; // Size low byte\n      blockHeader[2] = (compressedBlock.length >> 8) & 0xFF; // Size high byte\n      \n      // Store block and metadata\n      blocks.push(blockHeader);\n      blocks.push(compressedBlock);\n      blockStrategies.push(blockStrategy);\n      blockSizes.push(compressedBlock.length);\n    }\n    \n    // Calculate total size needed\n    let totalSize = 5; // Header size\n    for (let i = 0; i < numBlocks; i++) {\n      totalSize += 3; // Block header size\n      totalSize += blockSizes[i]; // Block data size\n    }\n    \n    // Combine all blocks\n    const result = new Uint8Array(totalSize);\n    let offset = 0;\n    \n    // Copy all blocks to result\n    for (const block of blocks) {\n      result.set(block, offset);\n      offset += block.length;\n    }\n    \n    return result;\n  }\n  \n  /**\n   * Convert strategy name to ID for block headers\n   */\n  private getStrategyId(strategy: string): number {\n    switch (strategy) {\n      case 'pattern': return 1;\n      case 'sequential': return 2;\n      case 'spectral': return 3;\n      case 'dictionary': return 4;\n      default: return 0; // Auto or unknown\n    }\n  }\n  \n  /**\n   * Real decompression implementation with block support\n   */\n  private realDecompress(compressedData: Uint8Array): Promise<Uint8Array> {\n    return new Promise((resolve, reject) => {\n      try {\n        if (compressedData.length === 0) {\n          return resolve(new Uint8Array(0));\n        }\n        \n        // Check marker byte to determine compression type\n        const marker = compressedData[0];\n        \n        // Handle block-based compression first\n        if (marker === 0xB1) {\n          return this.decompressBlocks(compressedData).then(resolve).catch(reject);\n        }\n        \n        switch (marker) {\n          case 0xC0: // Constant data\n            if (compressedData.length < 3) {\n              return reject(new Error('Invalid constant data format'));\n            }\n            \n            const value = compressedData[1];\n            const length = compressedData[2];\n            \n            const constantResult = new Uint8Array(length);\n            constantResult.fill(value);\n            return resolve(constantResult);\n            \n          case 0xC1: // Repeating pattern\n            if (compressedData.length < 3) {\n              return reject(new Error('Invalid pattern data format'));\n            }\n            \n            const patternLength = compressedData[1];\n            const repeatCount = compressedData[2];\n            \n            if (compressedData.length < 3 + patternLength) {\n              return reject(new Error('Invalid pattern data length'));\n            }\n            \n            const pattern = compressedData.slice(3, 3 + patternLength);\n            const patternResult = new Uint8Array(patternLength * repeatCount);\n            \n            for (let i = 0; i < repeatCount; i++) {\n              patternResult.set(pattern, i * patternLength);\n            }\n            \n            return resolve(patternResult);\n            \n          case 0xF0: // RLE compression\n            {\n              const result = [];\n              let i = 1;\n              \n              while (i < compressedData.length) {\n                if (compressedData[i] === 0xFF && i + 2 < compressedData.length) {\n                  // Run\n                  const count = compressedData[i + 1];\n                  const value = compressedData[i + 2];\n                  for (let j = 0; j < count; j++) {\n                    result.push(value);\n                  }\n                  i += 3;\n                } else if (compressedData[i] < 128) {\n                  // Literal sequence\n                  const length = compressedData[i] + 1;\n                  for (let j = 0; j < length && i + 1 + j < compressedData.length; j++) {\n                    result.push(compressedData[i + 1 + j]);\n                  }\n                  i += length + 1;\n                } else {\n                  // Unknown marker, treat as literal\n                  result.push(compressedData[i]);\n                  i++;\n                }\n              }\n              \n              return resolve(new Uint8Array(result));\n            }\n            \n          case 0xF1: // Arithmetic sequence\n            if (compressedData.length < 5) {\n              return reject(new Error('Invalid arithmetic sequence data'));\n            }\n            \n            const start = compressedData[1];\n            const diff = compressedData[2];\n            const lengthLow = compressedData[3];\n            const lengthHigh = compressedData[4];\n            const seqLength = lengthLow | (lengthHigh << 8);\n            \n            const seqResult = new Uint8Array(seqLength);\n            let currentValue = start;\n            \n            for (let i = 0; i < seqLength; i++) {\n              seqResult[i] = currentValue;\n              currentValue = (currentValue + diff) % 256;\n            }\n            \n            return resolve(seqResult);\n            \n          case 0xF2: // Modulo sequence\n            if (compressedData.length < 3) {\n              return reject(new Error('Invalid modulo sequence data'));\n            }\n            \n            const modLengthLow = compressedData[1];\n            const modLengthHigh = compressedData[2];\n            const modLength = modLengthLow | (modLengthHigh << 8);\n            \n            const modResult = new Uint8Array(modLength);\n            \n            for (let i = 0; i < modLength; i++) {\n              modResult[i] = i % 256;\n            }\n            \n            return resolve(modResult);\n            \n          case 0xF3: // High-entropy data\n            if (compressedData.length < 3) {\n              return reject(new Error('Invalid high-entropy data format'));\n            }\n            \n            const entLengthLow = compressedData[1];\n            const entLengthHigh = compressedData[2];\n            const entLength = entLengthLow | (entLengthHigh << 8);\n            \n            if (compressedData.length < 3 + entLength) {\n              return reject(new Error('Invalid high-entropy data length'));\n            }\n            \n            return resolve(compressedData.slice(3, 3 + entLength));\n            \n          case 0xF4: // Range-compressed data\n            if (compressedData.length < 4) {\n              return reject(new Error('Invalid range-compressed data format'));\n            }\n            \n            const minVal = compressedData[1];\n            // Max value used for bit calculation below\n            const bitsPerValue = compressedData[3];\n            \n            // Calculate how many values we can extract\n            const valuesPerByte = Math.floor(8 / bitsPerValue);\n            const totalBytes = compressedData.length - 4;\n            const totalValues = totalBytes * valuesPerByte;\n            \n            const rangeResult = new Uint8Array(totalValues);\n            let resultIndex = 0;\n            \n            // Bit mask for extracting values\n            const mask = (1 << bitsPerValue) - 1;\n            \n            // We're intentionally not using maxVal currently, but we might in future versions\n            // to handle more sophisticated range compression\n            \n            for (let i = 0; i < totalBytes && resultIndex < totalValues; i++) {\n              const currentByte = compressedData[i + 4];\n              \n              for (let j = 0; j < valuesPerByte && resultIndex < totalValues; j++) {\n                // Extract value and denormalize\n                const normalizedValue = (currentByte >> (j * bitsPerValue)) & mask;\n                rangeResult[resultIndex++] = minVal + normalizedValue;\n              }\n            }\n            \n            return resolve(rangeResult);\n            \n          case 0xF5: // Delta encoding\n            if (compressedData.length < 2) {\n              return reject(new Error('Invalid delta-encoded data format'));\n            }\n            \n            const firstByte = compressedData[1];\n            const deltaResult = new Uint8Array(compressedData.length - 1);\n            deltaResult[0] = firstByte;\n            \n            // Reconstruct from deltas\n            for (let i = 1; i < deltaResult.length; i++) {\n              const delta = compressedData[i + 1];\n              // Convert from unsigned byte to signed delta\n              const signedDelta = delta <= 127 ? delta : delta - 256;\n              deltaResult[i] = (deltaResult[i-1] + signedDelta) & 0xFF;\n            }\n            \n            return resolve(deltaResult);\n            \n          case 0xF6: // Dictionary compression\n            if (compressedData.length < 3) {\n              return reject(new Error('Invalid dictionary compressed data'));\n            }\n            \n            const dictSize = compressedData[1];\n            if (dictSize === 0 || compressedData.length < 2 + dictSize * 2) {\n              return reject(new Error('Invalid dictionary size'));\n            }\n            \n            // Read dictionary\n            const dictionary = [];\n            let offset = 2;\n            \n            for (let i = 0; i < dictSize; i++) {\n              dictionary.push([compressedData[offset], compressedData[offset + 1]]);\n              offset += 2;\n            }\n            \n            // Decompress data\n            const dictResult = [];\n            \n            while (offset < compressedData.length) {\n              if ((compressedData[offset] & 0xF0) === 0xE0) {\n                // Dictionary reference\n                const dictIndex = compressedData[offset] & 0x0F;\n                if (dictIndex < dictionary.length) {\n                  dictResult.push(dictionary[dictIndex][0], dictionary[dictIndex][1]);\n                } else {\n                  dictResult.push(compressedData[offset]);\n                }\n                offset++;\n              } else {\n                // Literal byte\n                dictResult.push(compressedData[offset]);\n                offset++;\n              }\n            }\n            \n            return resolve(new Uint8Array(dictResult));\n            \n          case 0xF7: // Uncompressed data\n            if (compressedData.length < 3) {\n              return reject(new Error('Invalid uncompressed data format'));\n            }\n            \n            const rawLengthLow = compressedData[1];\n            const rawLengthHigh = compressedData[2];\n            const rawLength = rawLengthLow | (rawLengthHigh << 8);\n            \n            if (compressedData.length < 3 + rawLength) {\n              return reject(new Error('Invalid uncompressed data length'));\n            }\n            \n            return resolve(compressedData.slice(3, 3 + rawLength));\n            \n          default:\n            // Unknown compression, or raw data - return as is\n            return resolve(compressedData);\n        }\n      } catch (error) {\n        console.error('Decompression error:', error);\n        const errorMessage = error instanceof Error \n          ? error.message \n          : String(error);\n        reject(new Error(`Decompression error: ${errorMessage || 'Unknown error'}`));\n      }\n    });\n  }\n  \n  /**\n   * Decompress block-based compression format\n   */\n  private async decompressBlocks(compressedData: Uint8Array): Promise<Uint8Array> {\n    if (compressedData.length < 5) {\n      throw new Error('Invalid block-compressed data format');\n    }\n    \n    // Read header\n    const blockCountLow = compressedData[1];\n    const blockCountHigh = compressedData[2];\n    const blockCount = blockCountLow | (blockCountHigh << 8);\n    \n    // Skip the block size bytes (bytes 3-4) as we don't need them for decompression\n    // Each block has its own size in its header\n    \n    // An array to hold all decompressed blocks\n    const decompressedBlocks: Uint8Array[] = [];\n    let offset = 5; // Start after header\n    \n    // Decompress each block\n    for (let i = 0; i < blockCount; i++) {\n      if (offset + 3 > compressedData.length) {\n        throw new Error(`Invalid block header at block ${i}`);\n      }\n      \n      // Read block header\n      const strategyId = compressedData[offset];\n      const blockLengthLow = compressedData[offset + 1];\n      const blockLengthHigh = compressedData[offset + 2];\n      const blockLength = blockLengthLow | (blockLengthHigh << 8);\n      \n      offset += 3;\n      \n      if (offset + blockLength > compressedData.length) {\n        throw new Error(`Invalid block data length at block ${i}`);\n      }\n      \n      // Extract block data\n      const blockData = compressedData.slice(offset, offset + blockLength);\n      offset += blockLength;\n      \n      // Determine strategy from ID\n      const strategy = this.getStrategyFromId(strategyId);\n      \n      // Decompress this block according to its strategy\n      // Add the appropriate marker\n      const markerByte = this.getMarkerForStrategy(strategy, blockData);\n      \n      // Create a new array with the marker + the block data\n      const markedBlockData = new Uint8Array(blockData.length + 1);\n      markedBlockData[0] = markerByte;\n      markedBlockData.set(blockData, 1);\n      \n      // Decompress this block\n      const decompressedBlock = await this.realDecompress(markedBlockData);\n      decompressedBlocks.push(decompressedBlock);\n    }\n    \n    // Calculate total decompressed size\n    let totalSize = 0;\n    for (const block of decompressedBlocks) {\n      totalSize += block.length;\n    }\n    \n    // Combine all blocks\n    const result = new Uint8Array(totalSize);\n    let outputOffset = 0;\n    \n    for (const block of decompressedBlocks) {\n      result.set(block, outputOffset);\n      outputOffset += block.length;\n    }\n    \n    return result;\n  }\n  \n  /**\n   * Get strategy name from ID for block headers\n   */\n  private getStrategyFromId(id: number): string {\n    switch (id) {\n      case 1: return 'pattern';\n      case 2: return 'sequential';\n      case 3: return 'spectral';\n      case 4: return 'dictionary';\n      default: return 'auto';\n    }\n  }\n  \n  /**\n   * Get the appropriate marker byte for a compression strategy\n   * when decompressing blocks\n   */\n  private getMarkerForStrategy(strategy: string, data: Uint8Array): number {\n    // Detect the marker based on data patterns if not available directly\n    switch (strategy) {\n      case 'pattern':\n        return data.length > 0 && data[0] === 0xFF ? 0xF0 : 0xC0;\n      case 'sequential':\n        return 0xF1;\n      case 'spectral':\n        return 0xF5; // Default to delta encoding\n      case 'dictionary':\n        return 0xF6;\n      default:\n        return 0xF7; // Default to uncompressed\n    }\n  }\n\n  /**\n   * Get available compression strategies\n   */\n  private realGetAvailableStrategies(): Promise<{ id: string, name: string }[]> {\n    return Promise.resolve([\n      { id: 'auto', name: 'Auto (Best)' },\n      { id: 'pattern', name: 'Pattern Recognition' },\n      { id: 'sequential', name: 'Sequential' },\n      { id: 'spectral', name: 'Spectral' },\n      { id: 'dictionary', name: 'Dictionary' }\n    ]);\n  }\n}\n\n// Export the singleton instance\nexport default PrimeCompressWasm.getInstance();"],"names":["WasmStatus","PrimeCompressWasm","constructor","status","NOT_LOADED","error","wasmModule","loadPromise","getInstance","instance","getStatus","this","getError","load","LOADED","Promise","resolve","LOADING","reject","console","log","strategies","pattern","patternCompress","bind","sequential","sequentialCompress","spectral","spectralCompress","dictionary","dictionaryCompress","auto","autoCompress","compress","realCompress","decompress","realDecompress","getAvailableStrategies","realGetAvailableStrategies","err","ERROR","Error","String","data","options","arguments","length","undefined","compressedData","calculateChecksum","hash","i","toString","padStart","calculateEntropy","counts","Array","fill","entropy","p","Math","log2","stats","analyzeBlock","isConstant","hasPattern","strategy","entropyScore","hasSequence","isTextLike","hasSpectralPattern","firstByte","detectPattern","detectSequence","detectSpectralPattern","allSame","min","patternLength","isPattern","currentByte","runLength","maxRunLength","diffs","push","firstDiff","every","diff","firstDerivative","signChanges","lastSign","currentDiff","currentSign","textChars","wordChars","spaces","sampleSize","Uint8Array","result","patternFound","from","slice","floor","litLength","maxLitLength","nextByte","nextRunLength","j","isModulo","set","max","bitsRequired","ceil","bitsFilled","normalizedValue","delta","freqTable","pairs","Map","pairHash","get","sortedPairs","entries","sort","a","b","map","entry","compressed","byte1","byte2","dictIndex","indexOf","startTime","performance","now","strategyToUse","autoSelectedStrategy","useBlocks","compressWithBlocks","compressionRatio","compressionTime","originalSize","compressedSize","errorMessage","message","defaultStrategy","blockSize","numBlocks","blocks","blockStrategies","blockSizes","header","blockStart","blockEnd","block","compressedBlock","blockStrategy","blockHeader","strategyId","getStrategyId","totalSize","offset","marker","decompressBlocks","then","catch","value","constantResult","repeatCount","patternResult","count","start","lengthLow","seqLength","seqResult","currentValue","modLengthLow","modLength","modResult","entLengthLow","entLength","minVal","bitsPerValue","valuesPerByte","totalBytes","totalValues","rangeResult","resultIndex","mask","deltaResult","signedDelta","dictSize","dictResult","rawLengthLow","rawLength","blockCount","decompressedBlocks","blockLength","blockData","getStrategyFromId","markerByte","getMarkerForStrategy","markedBlockData","decompressedBlock","outputOffset","id","name"],"sourceRoot":""}